<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>pluginplay: pluginplay::detail_::ModuleManagerPIMPL Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">pluginplay
   &#160;<span id="projectnumber">1.0.45</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pluginplay</b></li><li class="navelem"><b>detail_</b></li><li class="navelem"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html">ModuleManagerPIMPL</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pluginplay::detail_::ModuleManagerPIMPL Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The class that implements the <a class="el" href="classpluginplay_1_1ModuleManager.html" title="Class responsible for holding and managing modules.">ModuleManager</a>.  
 <a href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="module__manager__pimpl_8hpp_source.html">module_manager_pimpl.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a742d8aff4407a45111ddd8effab64376"><td class="memItemLeft" align="right" valign="top"><a id="a742d8aff4407a45111ddd8effab64376"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a742d8aff4407a45111ddd8effab64376">module_manager_type</a> = <a class="el" href="classpluginplay_1_1ModuleManager.html">ModuleManager</a></td></tr>
<tr class="memdesc:a742d8aff4407a45111ddd8effab64376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type *this implements. <br /></td></tr>
<tr class="separator:a742d8aff4407a45111ddd8effab64376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a57d93e95e28e75287f5f6db69cc2ecb4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a57d93e95e28e75287f5f6db69cc2ecb4">module_base_ptr</a> = <a class="el" href="classpluginplay_1_1ModuleManager.html#ae507121faff2c11b50d3151bff64c873">module_manager_type::module_base_ptr</a></td></tr>
<tr class="separator:a57d93e95e28e75287f5f6db69cc2ecb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9215f5e076632b314524263826a672f9"><td class="memItemLeft" align="right" valign="top"><a id="a9215f5e076632b314524263826a672f9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a9215f5e076632b314524263826a672f9">const_module_base_ptr</a> = <a class="el" href="classpluginplay_1_1ModuleManager.html#a709d144fe07f7e1a4cad0357b170bd6d">module_manager_type::const_module_base_ptr</a></td></tr>
<tr class="memdesc:a9215f5e076632b314524263826a672f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to a read-only module implementation. <br /></td></tr>
<tr class="separator:a9215f5e076632b314524263826a672f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef4cea5e253855401746745f27c02f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#abef4cea5e253855401746745f27c02f4">base_map</a> = std::map&lt; std::type_index, <a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a9215f5e076632b314524263826a672f9">const_module_base_ptr</a> &gt;</td></tr>
<tr class="separator:abef4cea5e253855401746745f27c02f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea69e3a0fe511e38d2637af68335945e"><td class="memItemLeft" align="right" valign="top"><a id="aea69e3a0fe511e38d2637af68335945e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aea69e3a0fe511e38d2637af68335945e">shared_module</a> = std::shared_ptr&lt; <a class="el" href="classpluginplay_1_1Module.html">Module</a> &gt;</td></tr>
<tr class="memdesc:aea69e3a0fe511e38d2637af68335945e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a usable module. <br /></td></tr>
<tr class="separator:aea69e3a0fe511e38d2637af68335945e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51fc6c40213aa5ac909563780a8012e"><td class="memItemLeft" align="right" valign="top"><a id="ac51fc6c40213aa5ac909563780a8012e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#ac51fc6c40213aa5ac909563780a8012e">module_map</a> = <a class="el" href="classpluginplay_1_1ModuleManager.html#a5890fdaeab7e35865b4f6de88c3e0892">module_manager_type::module_map</a></td></tr>
<tr class="memdesc:ac51fc6c40213aa5ac909563780a8012e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a map holding usable modules. <br /></td></tr>
<tr class="separator:ac51fc6c40213aa5ac909563780a8012e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2379e2f590fa48050845a92aed64d7f"><td class="memItemLeft" align="right" valign="top"><a id="aa2379e2f590fa48050845a92aed64d7f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aa2379e2f590fa48050845a92aed64d7f">default_map</a> = std::map&lt; std::type_index, <a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> &gt;</td></tr>
<tr class="memdesc:aa2379e2f590fa48050845a92aed64d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a map holding the default module key for a given property type. <br /></td></tr>
<tr class="separator:aa2379e2f590fa48050845a92aed64d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c01677075eafec37c471969afc51c3"><td class="memItemLeft" align="right" valign="top"><a id="ae5c01677075eafec37c471969afc51c3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#ae5c01677075eafec37c471969afc51c3">runtime_type</a> = <a class="el" href="classpluginplay_1_1ModuleManager.html#a1c5eed45f0f8c4d939b2f24ff4280704">module_manager_type::runtime_type</a></td></tr>
<tr class="memdesc:ae5c01677075eafec37c471969afc51c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the runtime. <br /></td></tr>
<tr class="separator:ae5c01677075eafec37c471969afc51c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc22e9ed0b23d1a72b150b0f0d560a84"><td class="memItemLeft" align="right" valign="top"><a id="acc22e9ed0b23d1a72b150b0f0d560a84"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#acc22e9ed0b23d1a72b150b0f0d560a84">runtime_ptr</a> = <a class="el" href="classpluginplay_1_1ModuleManager.html#a8b13e7a0da82f1d5464e6012d9558018">module_manager_type::runtime_ptr</a></td></tr>
<tr class="memdesc:acc22e9ed0b23d1a72b150b0f0d560a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to a runtime. <br /></td></tr>
<tr class="separator:acc22e9ed0b23d1a72b150b0f0d560a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f4875101ff6383fbe27f4efa0572ce"><td class="memItemLeft" align="right" valign="top"><a id="a93f4875101ff6383fbe27f4efa0572ce"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a93f4875101ff6383fbe27f4efa0572ce">cache_type</a> = <a class="el" href="classpluginplay_1_1ModuleManager.html#ad45032f024d9669f7feb74d76a796cd0">module_manager_type::cache_type</a></td></tr>
<tr class="memdesc:a93f4875101ff6383fbe27f4efa0572ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the cache. <br /></td></tr>
<tr class="separator:a93f4875101ff6383fbe27f4efa0572ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c64b530d24fb243c47887c741333653"><td class="memItemLeft" align="right" valign="top"><a id="a2c64b530d24fb243c47887c741333653"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a2c64b530d24fb243c47887c741333653">cache_pointer</a> = <a class="el" href="classpluginplay_1_1ModuleManager.html#a504bf3bd7177a586a51fdda6e7a42701">module_manager_type::cache_pointer</a></td></tr>
<tr class="memdesc:a2c64b530d24fb243c47887c741333653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to the cache. <br /></td></tr>
<tr class="separator:a2c64b530d24fb243c47887c741333653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b90ea48db42becef1e47667de8e182"><td class="memItemLeft" align="right" valign="top"><a id="a63b90ea48db42becef1e47667de8e182"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a63b90ea48db42becef1e47667de8e182">py_base_map</a> = std::map&lt; <a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a>, <a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a9215f5e076632b314524263826a672f9">const_module_base_ptr</a> &gt;</td></tr>
<tr class="memdesc:a63b90ea48db42becef1e47667de8e182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a map from key to Python implementation. <br /></td></tr>
<tr class="separator:a63b90ea48db42becef1e47667de8e182"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5b7a076e4b44908b2aefa17448940ffc"><td class="memItemLeft" align="right" valign="top"><a id="a5b7a076e4b44908b2aefa17448940ffc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ModuleManagerPIMPL</b> (<a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#acc22e9ed0b23d1a72b150b0f0d560a84">runtime_ptr</a> runtime, <a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a2c64b530d24fb243c47887c741333653">cache_pointer</a> cache)</td></tr>
<tr class="separator:a5b7a076e4b44908b2aefa17448940ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156bd4b3be18eb8b5e1487a33c4dab4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepluginplay_1_1type.html#a0bb9e510e66e3efb204cf5c278dabd7c">type::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a156bd4b3be18eb8b5e1487a33c4dab4b">count</a> (const <a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> &amp;key) const noexcept</td></tr>
<tr class="memdesc:a156bd4b3be18eb8b5e1487a33c4dab4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a deep copy of this instance on the heap.  <a href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a156bd4b3be18eb8b5e1487a33c4dab4b">More...</a><br /></td></tr>
<tr class="separator:a156bd4b3be18eb8b5e1487a33c4dab4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b63c72546b2c67027ecca562c863cb3"><td class="memItemLeft" align="right" valign="top"><a id="a1b63c72546b2c67027ecca562c863cb3"></a>
<a class="el" href="namespacepluginplay_1_1type.html#a0bb9e510e66e3efb204cf5c278dabd7c">type::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a1b63c72546b2c67027ecca562c863cb3">size</a> () const noexcept</td></tr>
<tr class="memdesc:a1b63c72546b2c67027ecca562c863cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures we count the number of modules consistently. <br /></td></tr>
<tr class="separator:a1b63c72546b2c67027ecca562c863cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4671dfdce0eec13b2c126aa916222f55"><td class="memItemLeft" align="right" valign="top">module_map::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a4671dfdce0eec13b2c126aa916222f55">begin</a> () noexcept</td></tr>
<tr class="memdesc:a4671dfdce0eec13b2c126aa916222f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the module map.  <a href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a4671dfdce0eec13b2c126aa916222f55">More...</a><br /></td></tr>
<tr class="separator:a4671dfdce0eec13b2c126aa916222f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b18dce75e700f5ab48327dcb740c160"><td class="memItemLeft" align="right" valign="top">module_map::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a8b18dce75e700f5ab48327dcb740c160">end</a> () noexcept</td></tr>
<tr class="memdesc:a8b18dce75e700f5ab48327dcb740c160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the past-the-end element of the module map.  <a href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a8b18dce75e700f5ab48327dcb740c160">More...</a><br /></td></tr>
<tr class="separator:a8b18dce75e700f5ab48327dcb740c160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7272272282ab306960406e5aa61406"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a0b7272272282ab306960406e5aa61406">set_default</a> (const std::type_info &amp;type, <a class="el" href="namespacepluginplay_1_1type.html#a5b3cceb4e9a4b73288a4e173b92ab50d">type::input_map</a> inputs, <a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> key)</td></tr>
<tr class="memdesc:a0b7272272282ab306960406e5aa61406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default module to use for a given property type.  <a href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a0b7272272282ab306960406e5aa61406">More...</a><br /></td></tr>
<tr class="separator:a0b7272272282ab306960406e5aa61406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95ab05fbd503c8e07738edf180a7eeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#ae95ab05fbd503c8e07738edf180a7eeb">add_module</a> (<a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> key, <a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a57d93e95e28e75287f5f6db69cc2ecb4">module_base_ptr</a> base)</td></tr>
<tr class="memdesc:ae95ab05fbd503c8e07738edf180a7eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function actually adds a module to the list of available modules.  <a href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#ae95ab05fbd503c8e07738edf180a7eeb">More...</a><br /></td></tr>
<tr class="separator:ae95ab05fbd503c8e07738edf180a7eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7fb8c8d46b45ff3133b106696e9a8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a5d7fb8c8d46b45ff3133b106696e9a8c">erase</a> (const <a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> &amp;key)</td></tr>
<tr class="memdesc:a5d7fb8c8d46b45ff3133b106696e9a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unloads the specified module.  <a href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a5d7fb8c8d46b45ff3133b106696e9a8c">More...</a><br /></td></tr>
<tr class="separator:a5d7fb8c8d46b45ff3133b106696e9a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41e4fd159a783b8c2c3c96940b2f26c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aa41e4fd159a783b8c2c3c96940b2f26c">copy_module</a> (const <a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> &amp;old_key, <a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> new_key)</td></tr>
<tr class="memdesc:aa41e4fd159a783b8c2c3c96940b2f26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a deep copy of a module.  <a href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aa41e4fd159a783b8c2c3c96940b2f26c">More...</a><br /></td></tr>
<tr class="separator:aa41e4fd159a783b8c2c3c96940b2f26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63c575fd030637c5f03ece9ddba0605"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aea69e3a0fe511e38d2637af68335945e">shared_module</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#ae63c575fd030637c5f03ece9ddba0605">at</a> (const <a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> &amp;key)</td></tr>
<tr class="memdesc:ae63c575fd030637c5f03ece9ddba0605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a module, filling in all non-set submodules with defaults if a ready default exists.  <a href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#ae63c575fd030637c5f03ece9ddba0605">More...</a><br /></td></tr>
<tr class="separator:ae63c575fd030637c5f03ece9ddba0605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison operators</div></td></tr>
<tr class="memitem:a2971b011c0c9669111b448c611e30064"><td class="memItemLeft" align="right" valign="top"><a id="a2971b011c0c9669111b448c611e30064"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html">ModuleManagerPIMPL</a> &amp;rhs) const</td></tr>
<tr class="separator:a2971b011c0c9669111b448c611e30064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e037e95c9d1980ab93d54fb8b739f9"><td class="memItemLeft" align="right" valign="top"><a id="ac6e037e95c9d1980ab93d54fb8b739f9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html">ModuleManagerPIMPL</a> &amp;rhs) const</td></tr>
<tr class="separator:ac6e037e95c9d1980ab93d54fb8b739f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b6a8c1d865de610b07b10dc98c6cd1"><td class="memItemLeft" align="right" valign="top"><a id="a16b6a8c1d865de610b07b10dc98c6cd1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_runtime</b> (<a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#acc22e9ed0b23d1a72b150b0f0d560a84">runtime_ptr</a> runtime) noexcept</td></tr>
<tr class="separator:a16b6a8c1d865de610b07b10dc98c6cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5e8adb5ec0b9c4b073daeee5883975"><td class="memItemLeft" align="right" valign="top"><a id="a5a5e8adb5ec0b9c4b073daeee5883975"></a>
<a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#ae5c01677075eafec37c471969afc51c3">runtime_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_runtime</b> () const</td></tr>
<tr class="separator:a5a5e8adb5ec0b9c4b073daeee5883975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5833930b6bf2889869dc30539a88d0"><td class="memItemLeft" align="right" valign="top"><a id="aac5833930b6bf2889869dc30539a88d0"></a>
<a class="el" href="classpluginplay_1_1ModuleManager.html#aba62f3cefe36f671b36cbd432f4f1243">ModuleManager::key_container_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>keys</b> () const</td></tr>
<tr class="separator:aac5833930b6bf2889869dc30539a88d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a3244abc584a1f24c2af14262b5250"><td class="memItemLeft" align="right" valign="top"><a id="ac5a3244abc584a1f24c2af14262b5250"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_cache</b> () const noexcept</td></tr>
<tr class="separator:ac5a3244abc584a1f24c2af14262b5250"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">ModuleManager state</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The members in this section are the state of the <a class="el" href="classpluginplay_1_1ModuleManager.html" title="Class responsible for holding and managing modules.">ModuleManager</a> class. </p>
</div></td></tr>
<tr class="memitem:a6bdbd621fe2f74dc95f09ea9c5e4aa21"><td class="memItemLeft" align="right" valign="top"><a id="a6bdbd621fe2f74dc95f09ea9c5e4aa21"></a>
<a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#abef4cea5e253855401746745f27c02f4">base_map</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_bases</b></td></tr>
<tr class="separator:a6bdbd621fe2f74dc95f09ea9c5e4aa21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c56512098f34acf3d4011c973c0bf34"><td class="memItemLeft" align="right" valign="top"><a id="a1c56512098f34acf3d4011c973c0bf34"></a>
<a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#ac51fc6c40213aa5ac909563780a8012e">module_map</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_modules</b></td></tr>
<tr class="separator:a1c56512098f34acf3d4011c973c0bf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59272583ba5fd308455333272a51120"><td class="memItemLeft" align="right" valign="top"><a id="aa59272583ba5fd308455333272a51120"></a>
<a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a63b90ea48db42becef1e47667de8e182">py_base_map</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_py_bases</b></td></tr>
<tr class="separator:aa59272583ba5fd308455333272a51120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f601def848f5d806a750e9e3405f8d"><td class="memItemLeft" align="right" valign="top"><a id="aa8f601def848f5d806a750e9e3405f8d"></a>
<a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a2c64b530d24fb243c47887c741333653">cache_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_pcaches</b></td></tr>
<tr class="separator:aa8f601def848f5d806a750e9e3405f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd56b70df204fc01fde0834e8430ab19"><td class="memItemLeft" align="right" valign="top"><a id="afd56b70df204fc01fde0834e8430ab19"></a>
<a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aa2379e2f590fa48050845a92aed64d7f">default_map</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_defaults</b></td></tr>
<tr class="separator:afd56b70df204fc01fde0834e8430ab19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d4842cc386daa0a0381865dcb0ad83"><td class="memItemLeft" align="right" valign="top"><a id="a92d4842cc386daa0a0381865dcb0ad83"></a>
std::map&lt; std::type_index, <a class="el" href="namespacepluginplay_1_1type.html#a5b3cceb4e9a4b73288a4e173b92ab50d">type::input_map</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_inputs</b></td></tr>
<tr class="separator:a92d4842cc386daa0a0381865dcb0ad83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83987f76911022db85087245f26671e8"><td class="memItemLeft" align="right" valign="top"><a id="a83987f76911022db85087245f26671e8"></a>
<a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#acc22e9ed0b23d1a72b150b0f0d560a84">runtime_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_runtime_</b></td></tr>
<tr class="separator:a83987f76911022db85087245f26671e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The class that implements the <a class="el" href="classpluginplay_1_1ModuleManager.html" title="Class responsible for holding and managing modules.">ModuleManager</a>. </p>
<p>Users are expected to go through the API provided by the <a class="el" href="classpluginplay_1_1ModuleManager.html" title="Class responsible for holding and managing modules.">ModuleManager</a> class. Inside the <a class="el" href="classpluginplay_1_1ModuleManager.html" title="Class responsible for holding and managing modules.">ModuleManager</a> class calls are redirected to this class. When using this class calls should go through the member functions as much as possible so that error checking occurs. That said members are public so that it is easier to test the implementation. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="abef4cea5e253855401746745f27c02f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef4cea5e253855401746745f27c02f4">&#9670;&nbsp;</a></span>base_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#abef4cea5e253855401746745f27c02f4">pluginplay::detail_::ModuleManagerPIMPL::base_map</a> =  std::map&lt;std::type_index, <a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a9215f5e076632b314524263826a672f9">const_module_base_ptr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of a map from the module implementation's type to the implementation </p>

</div>
</div>
<a id="a57d93e95e28e75287f5f6db69cc2ecb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d93e95e28e75287f5f6db69cc2ecb4">&#9670;&nbsp;</a></span>module_base_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a57d93e95e28e75287f5f6db69cc2ecb4">pluginplay::detail_::ModuleManagerPIMPL::module_base_ptr</a> =  <a class="el" href="classpluginplay_1_1ModuleManager.html#ae507121faff2c11b50d3151bff64c873">module_manager_type::module_base_ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of a pointer to a module's implemenation </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae95ab05fbd503c8e07738edf180a7eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae95ab05fbd503c8e07738edf180a7eeb">&#9670;&nbsp;</a></span>add_module()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::detail_::ModuleManagerPIMPL::add_module </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a57d93e95e28e75287f5f6db69cc2ecb4">module_base_ptr</a>&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function actually adds a module to the list of available modules. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key under which the module will be registered. </td></tr>
    <tr><td class="paramname">base</td><td>The instance containing the algorithm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae63c575fd030637c5f03ece9ddba0605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63c575fd030637c5f03ece9ddba0605">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aea69e3a0fe511e38d2637af68335945e">ModuleManagerPIMPL::shared_module</a> pluginplay::detail_::ModuleManagerPIMPL::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a module, filling in all non-set submodules with defaults if a ready default exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The module you want </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared_ptr to the requested module </dd></dl>

</div>
</div>
<a id="a4671dfdce0eec13b2c126aa916222f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4671dfdce0eec13b2c126aa916222f55">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">module_map::iterator pluginplay::detail_::ModuleManagerPIMPL::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the module map. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the map </dd></dl>

</div>
</div>
<a id="aa41e4fd159a783b8c2c3c96940b2f26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41e4fd159a783b8c2c3c96940b2f26c">&#9670;&nbsp;</a></span>copy_module()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::detail_::ModuleManagerPIMPL::copy_module </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> &amp;&#160;</td>
          <td class="paramname"><em>old_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a>&#160;</td>
          <td class="paramname"><em>new_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a deep copy of a module. </p>
<p>This function makes a deep copy of a module. The new module is unlocked regardless of whether the old module was locked or not. The user can call lock on the resulting module to make an exact copy </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_key</td><td>The key for the module to copy </td></tr>
    <tr><td class="paramname">new_key</td><td>The key under which the new module will live </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a156bd4b3be18eb8b5e1487a33c4dab4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156bd4b3be18eb8b5e1487a33c4dab4b">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepluginplay_1_1type.html#a0bb9e510e66e3efb204cf5c278dabd7c">type::size</a> pluginplay::detail_::ModuleManagerPIMPL::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a deep copy of this instance on the heap. </p>
<p>Ensures we determine if we have a module consistently </p>

</div>
</div>
<a id="a8b18dce75e700f5ab48327dcb740c160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b18dce75e700f5ab48327dcb740c160">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">module_map::iterator pluginplay::detail_::ModuleManagerPIMPL::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the past-the-end element of the module map. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the past-the-end element of the map </dd></dl>

</div>
</div>
<a id="a5d7fb8c8d46b45ff3133b106696e9a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7fb8c8d46b45ff3133b106696e9a8c">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::detail_::ModuleManagerPIMPL::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unloads the specified module. </p>
<p>This function unloads the module with the specified key. After this operation the key is free to be used again. Calling this function does NOT clean any data out of the cache. This function is a no-op if <code>key</code> does not exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key for the module which should be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b7272272282ab306960406e5aa61406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7272272282ab306960406e5aa61406">&#9670;&nbsp;</a></span>set_default()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::detail_::ModuleManagerPIMPL::set_default </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepluginplay_1_1type.html#a5b3cceb4e9a4b73288a4e173b92ab50d">type::input_map</a>&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a>&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the default module to use for a given property type. </p>
<p>When a user requests a module that module initially has no submodules set unless the user has bound some to that module. Instead, the <a class="el" href="classpluginplay_1_1ModuleManager.html" title="Class responsible for holding and managing modules.">ModuleManager</a> is now responsible to provide the module with submodules using the defaults. This function allows one to specify what the defaults are.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the property type this default is for </td></tr>
    <tr><td class="paramname">key</td><td>The module key for the module to use as the default </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>src/pluginplay/module_manager/detail_/<a class="el" href="module__manager__pimpl_8hpp_source.html">module_manager_pimpl.hpp</a></li>
<li>src/pluginplay/module_manager/detail_/module_manager_pimpl.ipp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
