<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>pluginplay: pluginplay::FieldTuple&lt; ElementType, FieldTypes &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">pluginplay
   &#160;<span id="projectnumber">1.0.27</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pluginplay</b></li><li class="navelem"><a class="el" href="classpluginplay_1_1FieldTuple.html">FieldTuple</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classpluginplay_1_1FieldTuple-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pluginplay::FieldTuple&lt; ElementType, FieldTypes &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Forward declare <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> so we can use the type.  
 <a href="classpluginplay_1_1FieldTuple.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="field__tuple_8hpp_source.html">field_tuple.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae6aba7151c65710a9d88c3c91556b997"><td class="memItemLeft" align="right" valign="top"><a id="ae6aba7151c65710a9d88c3c91556b997"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1FieldTuple.html#ae6aba7151c65710a9d88c3c91556b997">traits_type</a> = <a class="el" href="structpluginplay_1_1detail___1_1FieldTupleTraits.html">detail_::FieldTupleTraits</a>&lt; ElementType, FieldTypes... &gt;</td></tr>
<tr class="memdesc:ae6aba7151c65710a9d88c3c91556b997"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the traits class. <br /></td></tr>
<tr class="separator:ae6aba7151c65710a9d88c3c91556b997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1827c97cfef7ee34d1cad512c5cc8050"><td class="memItemLeft" align="right" valign="top"><a id="a1827c97cfef7ee34d1cad512c5cc8050"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1FieldTuple.html#a1827c97cfef7ee34d1cad512c5cc8050">key_type</a> = typename <a class="el" href="structpluginplay_1_1detail___1_1FieldTupleTraits.html#a29c0b594d2780278c59cb814c2eee579">traits_type::key_type</a></td></tr>
<tr class="memdesc:a1827c97cfef7ee34d1cad512c5cc8050"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a key used to retrieve a field. <br /></td></tr>
<tr class="separator:a1827c97cfef7ee34d1cad512c5cc8050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924e5ac37422b3e8cd9f2e3ec028563d"><td class="memItemLeft" align="right" valign="top"><a id="a924e5ac37422b3e8cd9f2e3ec028563d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1FieldTuple.html#a924e5ac37422b3e8cd9f2e3ec028563d">mapped_type</a> = typename <a class="el" href="structpluginplay_1_1detail___1_1FieldTupleTraits.html#a9c4d9612e0c2a1dba9a792802ac4f06e">traits_type::mapped_type</a></td></tr>
<tr class="memdesc:a924e5ac37422b3e8cd9f2e3ec028563d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the field. <br /></td></tr>
<tr class="separator:a924e5ac37422b3e8cd9f2e3ec028563d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c584f9b4db9542e2eb0300903fb3d1"><td class="memItemLeft" align="right" valign="top"><a id="af3c584f9b4db9542e2eb0300903fb3d1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1FieldTuple.html#af3c584f9b4db9542e2eb0300903fb3d1">value_type</a> = typename <a class="el" href="structpluginplay_1_1detail___1_1FieldTupleTraits.html#a9a24ca4e099502f3351d9951770818dc">traits_type::value_type</a></td></tr>
<tr class="memdesc:af3c584f9b4db9542e2eb0300903fb3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">How we're storing the key-value pair, name from std::map. <br /></td></tr>
<tr class="separator:af3c584f9b4db9542e2eb0300903fb3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46d1646953ecd9bb3f3f11a95e6a387"><td class="memItemLeft" align="right" valign="top"><a id="ab46d1646953ecd9bb3f3f11a95e6a387"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1FieldTuple.html#ab46d1646953ecd9bb3f3f11a95e6a387">iterator</a> = typename <a class="el" href="structpluginplay_1_1detail___1_1FieldTupleTraits.html#a266202a6989f26aec9d48cb433ff7115">traits_type::iterator</a></td></tr>
<tr class="memdesc:ab46d1646953ecd9bb3f3f11a95e6a387"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a read/write iterator over this class. <br /></td></tr>
<tr class="separator:ab46d1646953ecd9bb3f3f11a95e6a387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffc458836d576625fd5883073508aa2"><td class="memItemLeft" align="right" valign="top"><a id="a0ffc458836d576625fd5883073508aa2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1FieldTuple.html#a0ffc458836d576625fd5883073508aa2">const_iterator</a> = typename <a class="el" href="structpluginplay_1_1detail___1_1FieldTupleTraits.html#a107c1bba20ece257091de0c88c56099c">traits_type::const_iterator</a></td></tr>
<tr class="memdesc:a0ffc458836d576625fd5883073508aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a read-only iterator. <br /></td></tr>
<tr class="separator:a0ffc458836d576625fd5883073508aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6766bb08829d4293780133260fb7e906"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1FieldTuple.html#a6766bb08829d4293780133260fb7e906">~FieldTuple</a> ()=default</td></tr>
<tr class="memdesc:a6766bb08829d4293780133260fb7e906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard dtor.  <a href="classpluginplay_1_1FieldTuple.html#a6766bb08829d4293780133260fb7e906">More...</a><br /></td></tr>
<tr class="separator:a6766bb08829d4293780133260fb7e906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634111b36f3d4d8dd0c4fcc5a81d9a95"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a634111b36f3d4d8dd0c4fcc5a81d9a95"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1FieldTuple.html#a634111b36f3d4d8dd0c4fcc5a81d9a95">add_field</a> (<a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> key)</td></tr>
<tr class="memdesc:a634111b36f3d4d8dd0c4fcc5a81d9a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds another field to the API.  <a href="classpluginplay_1_1FieldTuple.html#a634111b36f3d4d8dd0c4fcc5a81d9a95">More...</a><br /></td></tr>
<tr class="separator:a634111b36f3d4d8dd0c4fcc5a81d9a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2834038301a9b1276b5dd250475487"><td class="memTemplParams" colspan="2"><a id="a1e2834038301a9b1276b5dd250475487"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a1e2834038301a9b1276b5dd250475487"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_field</b> (<a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> key, U &amp;&amp;value)</td></tr>
<tr class="separator:a1e2834038301a9b1276b5dd250475487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93dd43da5dcc441ec1578d0933254f6d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93dd43da5dcc441ec1578d0933254f6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1FieldTuple.html#a93dd43da5dcc441ec1578d0933254f6d">set_default</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a93dd43da5dcc441ec1578d0933254f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default value of the most recently added field.  <a href="classpluginplay_1_1FieldTuple.html#a93dd43da5dcc441ec1578d0933254f6d">More...</a><br /></td></tr>
<tr class="separator:a93dd43da5dcc441ec1578d0933254f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491871baa07a36714504434452fe8862"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepluginplay_1_1type.html#a0bb9e510e66e3efb204cf5c278dabd7c">type::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1FieldTuple.html#a491871baa07a36714504434452fe8862">count</a> (const <a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> &amp;key) const noexcept</td></tr>
<tr class="memdesc:a491871baa07a36714504434452fe8862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of fields with a particular key.  <a href="classpluginplay_1_1FieldTuple.html#a491871baa07a36714504434452fe8862">More...</a><br /></td></tr>
<tr class="separator:a491871baa07a36714504434452fe8862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Ctor and assignment operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The functions in this section can be used to create a new instance with a specified state or set the current instance to the state of another instance. Since we need to keep track of the type of each field it is only possible to modify the values held in the object and not to add more. Adding another field requires creating a new instance, which is done with the <code>add_field</code> member.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The instance to copy/move the state from. For move operations <code>rhs</code> is in a valid, but otherwise undefined state after the operation. </td></tr>
    <tr><td class="paramname">values</td><td>For 6, this array contains the values of each field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>assignment operators return the current instance with the state set to/taken from the other instance. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>copy operations throw if there is insufficient memory to copy a field instance's state. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">none</td><td>1, and 4-6 are all no throw guarantee. </td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr class="memitem:a504f5837611e8672c41f0139ec1c3f05"><td class="memItemLeft" align="right" valign="top"><a id="a504f5837611e8672c41f0139ec1c3f05"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FieldTuple</b> ()=default</td></tr>
<tr class="separator:a504f5837611e8672c41f0139ec1c3f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f1377236d83d19b3c4b4a370fc3bc1"><td class="memItemLeft" align="right" valign="top"><a id="a27f1377236d83d19b3c4b4a370fc3bc1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FieldTuple</b> (const <a class="el" href="classpluginplay_1_1FieldTuple.html">FieldTuple</a> &amp;rhs)=default</td></tr>
<tr class="separator:a27f1377236d83d19b3c4b4a370fc3bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6d8c189d98a79addb9a4b8ad3e3761"><td class="memItemLeft" align="right" valign="top"><a id="acb6d8c189d98a79addb9a4b8ad3e3761"></a>
<a class="el" href="classpluginplay_1_1FieldTuple.html">FieldTuple</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classpluginplay_1_1FieldTuple.html">FieldTuple</a> &amp;rhs)=default</td></tr>
<tr class="separator:acb6d8c189d98a79addb9a4b8ad3e3761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa5b3b9f8840456a46620e5ae9e21a6"><td class="memItemLeft" align="right" valign="top"><a id="aaaa5b3b9f8840456a46620e5ae9e21a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FieldTuple</b> (<a class="el" href="classpluginplay_1_1FieldTuple.html">FieldTuple</a> &amp;&amp;rhs)=default</td></tr>
<tr class="separator:aaaa5b3b9f8840456a46620e5ae9e21a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1d1ca65c3f3a323ec3270cb14363c5"><td class="memItemLeft" align="right" valign="top"><a id="a8c1d1ca65c3f3a323ec3270cb14363c5"></a>
<a class="el" href="classpluginplay_1_1FieldTuple.html">FieldTuple</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classpluginplay_1_1FieldTuple.html">FieldTuple</a> &amp;&amp;rhs)=default</td></tr>
<tr class="separator:a8c1d1ca65c3f3a323ec3270cb14363c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72e07e0c1ae97b3ef54b3a8a7268d5d"><td class="memItemLeft" align="right" valign="top"><a id="af72e07e0c1ae97b3ef54b3a8a7268d5d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FieldTuple</b> (std::array&lt; <a class="el" href="classpluginplay_1_1FieldTuple.html#af3c584f9b4db9542e2eb0300903fb3d1">value_type</a>, <a class="el" href="structpluginplay_1_1detail___1_1FieldTupleTraits.html#a6ab7556577030c7ee86c3008a8fc7937">traits_type::nfields</a> &gt; values) noexcept</td></tr>
<tr class="separator:af72e07e0c1ae97b3ef54b3a8a7268d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Field accessors</div></td></tr>
<tr class="memitem:af8ccafec8f2a596c7fb117fb3835c353"><td class="memItemLeft" align="right" valign="top"><a id="af8ccafec8f2a596c7fb117fb3835c353"></a>
auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const <a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> &amp;key)</td></tr>
<tr class="separator:af8ccafec8f2a596c7fb117fb3835c353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce692208a95331f4e415a11c37aa8ad"><td class="memItemLeft" align="right" valign="top"><a id="a0ce692208a95331f4e415a11c37aa8ad"></a>
const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const <a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> &amp;key) const</td></tr>
<tr class="separator:a0ce692208a95331f4e415a11c37aa8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492373dae8c59b6f996a893ea9c1986c"><td class="memItemLeft" align="right" valign="top"><a id="a492373dae8c59b6f996a893ea9c1986c"></a>
auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (const <a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> &amp;key)</td></tr>
<tr class="separator:a492373dae8c59b6f996a893ea9c1986c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdfbee4bdf73034a7c8a93f24155e47"><td class="memItemLeft" align="right" valign="top"><a id="a9bdfbee4bdf73034a7c8a93f24155e47"></a>
const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (const <a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> &amp;key) const</td></tr>
<tr class="separator:a9bdfbee4bdf73034a7c8a93f24155e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The functions in this section can be used to retrieve iterators that run over the instance. Iterators are bidirectional. Variants 1 and 4 return iterators that can be used to read or modify the fields, wheras all other variants return read-only iterators. The first three variants return an iterator pointing at the first field in the API and the last three return an iterator just past the last field in the API.</p>
<dl class="section return"><dt>Returns</dt><dd>the requested iterator. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr class="memitem:ad1bd1bafedbe16a4c1d02178e549c208"><td class="memItemLeft" align="right" valign="top"><a id="ad1bd1bafedbe16a4c1d02178e549c208"></a>
<a class="el" href="classpluginplay_1_1FieldTuple.html#ab46d1646953ecd9bb3f3f11a95e6a387">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () noexcept</td></tr>
<tr class="separator:ad1bd1bafedbe16a4c1d02178e549c208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c4510bbd15720c8a4a7c0a2b36f95c"><td class="memItemLeft" align="right" valign="top"><a id="a83c4510bbd15720c8a4a7c0a2b36f95c"></a>
<a class="el" href="classpluginplay_1_1FieldTuple.html#a0ffc458836d576625fd5883073508aa2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const noexcept</td></tr>
<tr class="separator:a83c4510bbd15720c8a4a7c0a2b36f95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092f72008f0da2ed5a25a710f4237c58"><td class="memItemLeft" align="right" valign="top"><a id="a092f72008f0da2ed5a25a710f4237c58"></a>
<a class="el" href="classpluginplay_1_1FieldTuple.html#a0ffc458836d576625fd5883073508aa2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const noexcept</td></tr>
<tr class="separator:a092f72008f0da2ed5a25a710f4237c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9588e502443ddb682d6e47fa2de3bfbf"><td class="memItemLeft" align="right" valign="top"><a id="a9588e502443ddb682d6e47fa2de3bfbf"></a>
<a class="el" href="classpluginplay_1_1FieldTuple.html#ab46d1646953ecd9bb3f3f11a95e6a387">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () noexcept</td></tr>
<tr class="separator:a9588e502443ddb682d6e47fa2de3bfbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e4c6d874f3964e541f3b821e28397b"><td class="memItemLeft" align="right" valign="top"><a id="a67e4c6d874f3964e541f3b821e28397b"></a>
<a class="el" href="classpluginplay_1_1FieldTuple.html#a0ffc458836d576625fd5883073508aa2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const noexcept</td></tr>
<tr class="separator:a67e4c6d874f3964e541f3b821e28397b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997e0a8f26c730323ac38439a1997955"><td class="memItemLeft" align="right" valign="top"><a id="a997e0a8f26c730323ac38439a1997955"></a>
<a class="el" href="classpluginplay_1_1FieldTuple.html#a0ffc458836d576625fd5883073508aa2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const noexcept</td></tr>
<tr class="separator:a997e0a8f26c730323ac38439a1997955"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3fe06352fc4c6572c1d41ce7aa62e8fb"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespacepluginplay_1_1type.html#a0bb9e510e66e3efb204cf5c278dabd7c">type::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1FieldTuple.html#a3fe06352fc4c6572c1d41ce7aa62e8fb">size</a> () noexcept</td></tr>
<tr class="memdesc:a3fe06352fc4c6572c1d41ce7aa62e8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of fields.  <a href="classpluginplay_1_1FieldTuple.html#a3fe06352fc4c6572c1d41ce7aa62e8fb">More...</a><br /></td></tr>
<tr class="separator:a3fe06352fc4c6572c1d41ce7aa62e8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af8cd77ce02e3e624c12dec962f0988ae"><td class="memItemLeft" align="right" valign="top"><a id="af8cd77ce02e3e624c12dec962f0988ae"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1FieldTuple.html#af8cd77ce02e3e624c12dec962f0988ae">is_input</a> = std::is_same_v&lt;ElementType, <a class="el" href="classpluginplay_1_1ModuleInput.html">ModuleInput</a>&gt;</td></tr>
<tr class="memdesc:af8cd77ce02e3e624c12dec962f0988ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this Field tuple for inputs? If not it's for results. <br /></td></tr>
<tr class="separator:af8cd77ce02e3e624c12dec962f0988ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a779529e071eb69648de90aac2082668c"><td class="memTemplParams" colspan="2">template&lt;typename LHSType , typename... LHSTypes, typename RHSType , typename... RHSTypes&gt; </td></tr>
<tr class="memitem:a779529e071eb69648de90aac2082668c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1FieldTuple.html#a779529e071eb69648de90aac2082668c">operator==</a> (const <a class="el" href="classpluginplay_1_1FieldTuple.html">FieldTuple</a>&lt; LHSType, LHSTypes... &gt; &amp;lhs, const <a class="el" href="classpluginplay_1_1FieldTuple.html">FieldTuple</a>&lt; RHSType, RHSTypes... &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a779529e071eb69648de90aac2082668c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> instances for equality.  <a href="classpluginplay_1_1FieldTuple.html#a779529e071eb69648de90aac2082668c">More...</a><br /></td></tr>
<tr class="separator:a779529e071eb69648de90aac2082668c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c94fec2e43e0eadc22ca0e421d63ba"><td class="memTemplParams" colspan="2">template&lt;typename LHSType , typename... LHSTypes, typename RHSType , typename... RHSTypes&gt; </td></tr>
<tr class="memitem:ad5c94fec2e43e0eadc22ca0e421d63ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1FieldTuple.html#ad5c94fec2e43e0eadc22ca0e421d63ba">operator!=</a> (const <a class="el" href="classpluginplay_1_1FieldTuple.html">FieldTuple</a>&lt; LHSType, LHSTypes... &gt; &amp;lhs, const <a class="el" href="classpluginplay_1_1FieldTuple.html">FieldTuple</a>&lt; RHSType, RHSTypes... &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad5c94fec2e43e0eadc22ca0e421d63ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> instances are different.  <a href="classpluginplay_1_1FieldTuple.html#ad5c94fec2e43e0eadc22ca0e421d63ba">More...</a><br /></td></tr>
<tr class="separator:ad5c94fec2e43e0eadc22ca0e421d63ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679e2db9795d820ac38c8ec5b8593d7a"><td class="memTemplParams" colspan="2">template&lt;typename LHSType , typename RHSType , std::size_t depth = 0&gt; </td></tr>
<tr class="memitem:a679e2db9795d820ac38c8ec5b8593d7a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1FieldTuple.html#a679e2db9795d820ac38c8ec5b8593d7a">union_guts</a> (LHSType &amp;&amp;lhs, const RHSType &amp;rhs)</td></tr>
<tr class="memdesc:a679e2db9795d820ac38c8ec5b8593d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements operator+ for <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> <a href="classpluginplay_1_1FieldTuple.html#a679e2db9795d820ac38c8ec5b8593d7a">More...</a><br /></td></tr>
<tr class="separator:a679e2db9795d820ac38c8ec5b8593d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb352c20530e11e09b9776c201809de0"><td class="memTemplParams" colspan="2">template&lt;typename LHSType , typename... LHSTypes, typename RHSType , typename... RHSTypes&gt; </td></tr>
<tr class="memitem:afb352c20530e11e09b9776c201809de0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1FieldTuple.html#afb352c20530e11e09b9776c201809de0">operator+</a> (const <a class="el" href="classpluginplay_1_1FieldTuple.html">FieldTuple</a>&lt; LHSType, LHSTypes... &gt; &amp;lhs, const <a class="el" href="classpluginplay_1_1FieldTuple.html">FieldTuple</a>&lt; RHSType, RHSTypes... &gt; &amp;rhs)</td></tr>
<tr class="memdesc:afb352c20530e11e09b9776c201809de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of two <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> instances.  <a href="classpluginplay_1_1FieldTuple.html#afb352c20530e11e09b9776c201809de0">More...</a><br /></td></tr>
<tr class="separator:afb352c20530e11e09b9776c201809de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ElementType, typename... FieldTypes&gt;<br />
class pluginplay::FieldTuple&lt; ElementType, FieldTypes &gt;</h3>

<p>Forward declare <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> so we can use the type. </p>
<p>Records the property type's input or result API.</p>
<p>This class is responsible for holding the details of a property type's input or result fields. In particular this means that the class must retain:</p><ul>
<li>the order the fields were declared in,</li>
<li>the key for each field,</li>
<li>the type of each field's value, and</li>
<li>an input field's default value (only inputs may have default values)</li>
</ul>
<p>The <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> class works like a map from a field's name to either a <a class="el" href="classpluginplay_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form.">ModuleInput</a> or <a class="el" href="classpluginplay_1_1ModuleResult.html" title="Holds the results of calling a module&#39;s run function.">ModuleResult</a> instance (depending respectively on whether the instance is storing the inputs to or the results from calling a module).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ElementType</td><td>This will be either <a class="el" href="classpluginplay_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form.">ModuleInput</a> or <a class="el" href="classpluginplay_1_1ModuleResult.html" title="Holds the results of calling a module&#39;s run function.">ModuleResult</a> depending on whether we are building the input or result API specification respectively. </td></tr>
    <tr><td class="paramname">FieldTypes</td><td>These are the types of the inputs/results in the order they are accepted/returned. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6766bb08829d4293780133260fb7e906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6766bb08829d4293780133260fb7e906">&#9670;&nbsp;</a></span>~FieldTuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType , typename... FieldTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1FieldTuple.html">pluginplay::FieldTuple</a>&lt; ElementType, FieldTypes &gt;::~<a class="el" href="classpluginplay_1_1FieldTuple.html">FieldTuple</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard dtor. </p>
<p>After calling this function all references are invalidated.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a634111b36f3d4d8dd0c4fcc5a81d9a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634111b36f3d4d8dd0c4fcc5a81d9a95">&#9670;&nbsp;</a></span>add_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType , typename... FieldTypes&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classpluginplay_1_1FieldTuple.html">pluginplay::FieldTuple</a>&lt; ElementType, FieldTypes &gt;::add_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds another field to the API. </p>
<p>This function adds another field to the property type's API. In order to store the type of the new field the type of this class must change, which can only be done by making a new instance (with a new type). This function will make that new instance, move this instance's state to the new instance, and then return the new instance. After calling this function the current instance will be in a valid, but otherwise undefined state. References to the state of each field are still valid, but references to a field are not.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the field you are adding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The keyword to associate with this field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> instance which in </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is not enough memory to create the new field. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the provided key is already in use by another field. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a491871baa07a36714504434452fe8862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491871baa07a36714504434452fe8862">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType , typename... FieldTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepluginplay_1_1type.html#a0bb9e510e66e3efb204cf5c278dabd7c">type::size</a> <a class="el" href="classpluginplay_1_1FieldTuple.html">pluginplay::FieldTuple</a>&lt; ElementType, FieldTypes &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the number of fields with a particular key. </p>
<p>We require that each field have a unique keyword associated with it, hence this function can only return 0 or 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key we are looking for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the instance contains a field with a keyword <code>key</code> and 0 otherwise. </dd></dl>

</div>
</div>
<a id="a93dd43da5dcc441ec1578d0933254f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93dd43da5dcc441ec1578d0933254f6d">&#9670;&nbsp;</a></span>set_default()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType , typename... FieldTypes&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpluginplay_1_1FieldTuple.html">pluginplay::FieldTuple</a>&lt; ElementType, FieldTypes &gt;::set_default </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the default value of the most recently added field. </p>
<p>This function is used to set and/or change the default value of the most recently added field.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the default value. <code>T</code> must be implicitly convertable to the type of the field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The new default for the most recently added field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fe06352fc4c6572c1d41ce7aa62e8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe06352fc4c6572c1d41ce7aa62e8fb">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType , typename... FieldTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="namespacepluginplay_1_1type.html#a0bb9e510e66e3efb204cf5c278dabd7c">type::size</a> <a class="el" href="classpluginplay_1_1FieldTuple.html">pluginplay::FieldTuple</a>&lt; ElementType, FieldTypes &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of fields. </p>
<p>This is really a convenience function/prettier API since the number of fields can be read off the type.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of fields </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>no throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ad5c94fec2e43e0eadc22ca0e421d63ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c94fec2e43e0eadc22ca0e421d63ba">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHSType , typename... LHSTypes, typename RHSType , typename... RHSTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1FieldTuple.html">FieldTuple</a>&lt; LHSType, LHSTypes... &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1FieldTuple.html">FieldTuple</a>&lt; RHSType, RHSTypes... &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> instances are different. </p>
<p>Two <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> instances are equal if they have the fields have the same types, keys, and defaults. The fields must appear in the same order as well.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHSType</td><td>Assumed to be either <a class="el" href="classpluginplay_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form.">ModuleInput</a> or <a class="el" href="classpluginplay_1_1ModuleResult.html" title="Holds the results of calling a module&#39;s run function.">ModuleResult</a> depending on whether the <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> is for inputs or results respectively. </td></tr>
    <tr><td class="paramname">LHSTypes</td><td>The types of the fields in the <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> appearing on the left of <code>operator!=</code>. </td></tr>
    <tr><td class="paramname">RHSType</td><td>Assumed to be either <a class="el" href="classpluginplay_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form.">ModuleInput</a> or <a class="el" href="classpluginplay_1_1ModuleResult.html" title="Holds the results of calling a module&#39;s run function.">ModuleResult</a> depending on whether the <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> is for inputs or results respectively. </td></tr>
    <tr><td class="paramname">RHSTypes</td><td>The types of the fields in the <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> appearing on the left of the <code>operator!=</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> on the left of <code>operator!=</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> on the right of <code>operator!=</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> instances are different and false otherwise. </dd></dl>

</div>
</div>
<a id="afb352c20530e11e09b9776c201809de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb352c20530e11e09b9776c201809de0">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHSType , typename... LHSTypes, typename RHSType , typename... RHSTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1FieldTuple.html">FieldTuple</a>&lt; LHSType, LHSTypes... &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1FieldTuple.html">FieldTuple</a>&lt; RHSType, RHSTypes... &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the union of two <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> instances. </p>
<p>This function will take the union of two <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> instances. The resulting instance will be of type <code><a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a>&lt;LHSType, LHSTypes..., RHSTypes...&gt;</code>. The order of the fields will be those of <code>lhs</code>, in the same order they appear in <code>lhs</code>, followed by those in <code>rhs</code> (also in the same order they appear in <code>rhs</code>).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHSType</td><td>Assumed to be either <a class="el" href="classpluginplay_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form.">ModuleInput</a> or <a class="el" href="classpluginplay_1_1ModuleResult.html" title="Holds the results of calling a module&#39;s run function.">ModuleResult</a> depending on whether <code>lhs</code> is a <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> of inputs or results. </td></tr>
    <tr><td class="paramname">LHSTypes</td><td>The types of the fields appearing in <code>lhs</code>. </td></tr>
    <tr><td class="paramname">RHSType</td><td>Assumed to be either <a class="el" href="classpluginplay_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form.">ModuleInput</a> or <a class="el" href="classpluginplay_1_1ModuleResult.html" title="Holds the results of calling a module&#39;s run function.">ModuleResult</a> depending on whether <code>rhs</code> is a <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> of inputs or results. </td></tr>
    <tr><td class="paramname">RHSTypes</td><td>The types of the fields appearin in <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> on the left side of <code>operator+</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> on the right side of <code>operator+</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The union of <code>lhs</code> with <code>rhs</code>. </dd></dl>

</div>
</div>
<a id="a779529e071eb69648de90aac2082668c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779529e071eb69648de90aac2082668c">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHSType , typename... LHSTypes, typename RHSType , typename... RHSTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1FieldTuple.html">FieldTuple</a>&lt; LHSType, LHSTypes... &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1FieldTuple.html">FieldTuple</a>&lt; RHSType, RHSTypes... &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> instances for equality. </p>
<p>Two <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> instances are equal if they have the fields have the same types, keys, and defaults. The fields must appear in the same order as well.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHSType</td><td>Assumed to be either <a class="el" href="classpluginplay_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form.">ModuleInput</a> or <a class="el" href="classpluginplay_1_1ModuleResult.html" title="Holds the results of calling a module&#39;s run function.">ModuleResult</a> depending on whether the <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> is for inputs or results respectively. </td></tr>
    <tr><td class="paramname">LHSTypes</td><td>The types of the fields in the <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> appearing on the left of <code>operator==</code>. </td></tr>
    <tr><td class="paramname">RHSType</td><td>Assumed to be either <a class="el" href="classpluginplay_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form.">ModuleInput</a> or <a class="el" href="classpluginplay_1_1ModuleResult.html" title="Holds the results of calling a module&#39;s run function.">ModuleResult</a> depending on whether the <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> is for inputs or results respectively. </td></tr>
    <tr><td class="paramname">RHSTypes</td><td>The types of the fields in the <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> appearing on the left of the <code>operator==</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> on the left of <code>operator==</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> on the right of <code>operator==</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> instances are equal and false otherwise. </dd></dl>

</div>
</div>
<a id="a679e2db9795d820ac38c8ec5b8593d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679e2db9795d820ac38c8ec5b8593d7a">&#9670;&nbsp;</a></span>union_guts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHSType , typename RHSType , std::size_t depth = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto union_guts </td>
          <td>(</td>
          <td class="paramtype">LHSType &amp;&amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RHSType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements operator+ for <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a></p>
<p>Union of <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> instances is done by recursion. This function wraps the recursion logic. Users should go through the public API <code>operator+</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHSType</td><td>The type of the object on the left of <code>operator+</code>. Assumed to be a <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a>. </td></tr>
    <tr><td class="paramname">RHSType</td><td>The type of the object on the right of <code>operator+</code>. Assumed to be a <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a>. </td></tr>
    <tr><td class="paramname">depth</td><td>The index of the field being added. Must be in the range [0, sizeof(rhs)).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The object on the left of <code>operator+</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The object on the right of <code>operator+</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classpluginplay_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type.">FieldTuple</a> resulting from concatenating <code>lhs</code> with the last sizeof(rhs) - depth fields of <code>rhs</code>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/pluginplay/detail_/<a class="el" href="field__tuple__traits_8hpp_source.html">field_tuple_traits.hpp</a></li>
<li>include/pluginplay/property_type/<a class="el" href="field__tuple_8hpp_source.html">field_tuple.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
