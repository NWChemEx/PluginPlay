<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>pluginplay: pluginplay::any::AnyField Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">pluginplay
   &#160;<span id="projectnumber">1.0.44</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pluginplay</b></li><li class="navelem"><b>any</b></li><li class="navelem"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classpluginplay_1_1any_1_1AnyField-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pluginplay::any::AnyField Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Wraps either an input or a result to a module.  
 <a href="classpluginplay_1_1any_1_1AnyField.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="any__field_8hpp_source.html">any_field.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af6a7d66addbb9527eb3d13a7ce0881e8"><td class="memItemLeft" align="right" valign="top"><a id="af6a7d66addbb9527eb3d13a7ce0881e8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#af6a7d66addbb9527eb3d13a7ce0881e8">pimpl_type</a> = <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html">detail_::AnyFieldBase</a></td></tr>
<tr class="memdesc:af6a7d66addbb9527eb3d13a7ce0881e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the object actually implementing the <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> class. <br /></td></tr>
<tr class="separator:af6a7d66addbb9527eb3d13a7ce0881e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eedd962b805fe06bdba02abacb5cf96"><td class="memItemLeft" align="right" valign="top"><a id="a6eedd962b805fe06bdba02abacb5cf96"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#a6eedd962b805fe06bdba02abacb5cf96">rtti_type</a> = typename <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#aae51363b5fe4dfd20262c4613fb65fa8">pimpl_type::rtti_type</a></td></tr>
<tr class="memdesc:a6eedd962b805fe06bdba02abacb5cf96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for runtime type information (RTTI) purposes. <br /></td></tr>
<tr class="separator:a6eedd962b805fe06bdba02abacb5cf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b67b0e1045c23c6ddd967d19dbe81c"><td class="memItemLeft" align="right" valign="top"><a id="a86b67b0e1045c23c6ddd967d19dbe81c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#a86b67b0e1045c23c6ddd967d19dbe81c">pimpl_pointer</a> = typename <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#a56f22739d8829d8fd736e452fb237d2c">pimpl_type::field_base_pointer</a></td></tr>
<tr class="memdesc:a86b67b0e1045c23c6ddd967d19dbe81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the smart pointer holding a PIMPL, typedef of unique_ptr. <br /></td></tr>
<tr class="separator:a86b67b0e1045c23c6ddd967d19dbe81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa81faf61ea66dd872d350ba3277a0a6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#aa81faf61ea66dd872d350ba3277a0a6b">AnyField</a> (<a class="el" href="classpluginplay_1_1any_1_1AnyField.html#a86b67b0e1045c23c6ddd967d19dbe81c">pimpl_pointer</a> <a class="el" href="classpluginplay_1_1detail___1_1ModulePIMPL.html">pimpl</a>=nullptr) noexcept</td></tr>
<tr class="memdesc:aa81faf61ea66dd872d350ba3277a0a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> wrapping the provided value.  <a href="classpluginplay_1_1any_1_1AnyField.html#aa81faf61ea66dd872d350ba3277a0a6b">More...</a><br /></td></tr>
<tr class="separator:aa81faf61ea66dd872d350ba3277a0a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc108a8616b058bb379caae97e332271"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#adc108a8616b058bb379caae97e332271">AnyField</a> (const <a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;other)</td></tr>
<tr class="memdesc:adc108a8616b058bb379caae97e332271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> by deep copying an existing instance.  <a href="classpluginplay_1_1any_1_1AnyField.html#adc108a8616b058bb379caae97e332271">More...</a><br /></td></tr>
<tr class="separator:adc108a8616b058bb379caae97e332271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1deacd9e8f9c7fdc04c03c08791a241d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#a1deacd9e8f9c7fdc04c03c08791a241d">AnyField</a> (<a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a1deacd9e8f9c7fdc04c03c08791a241d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the state from an already existing <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> instance.  <a href="classpluginplay_1_1any_1_1AnyField.html#a1deacd9e8f9c7fdc04c03c08791a241d">More...</a><br /></td></tr>
<tr class="separator:a1deacd9e8f9c7fdc04c03c08791a241d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a93a22fb33a20a06b20b7395c3c308"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#ac0a93a22fb33a20a06b20b7395c3c308">operator=</a> (const <a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;rhs)</td></tr>
<tr class="memdesc:ac0a93a22fb33a20a06b20b7395c3c308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the existing state with a deep copy of another <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a>.  <a href="classpluginplay_1_1any_1_1AnyField.html#ac0a93a22fb33a20a06b20b7395c3c308">More...</a><br /></td></tr>
<tr class="separator:ac0a93a22fb33a20a06b20b7395c3c308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c50cb423847e2024a9bf9bf83ea6bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#ab9c50cb423847e2024a9bf9bf83ea6bb">operator=</a> (<a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:ab9c50cb423847e2024a9bf9bf83ea6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the existing state with another <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a>'s state.  <a href="classpluginplay_1_1any_1_1AnyField.html#ab9c50cb423847e2024a9bf9bf83ea6bb">More...</a><br /></td></tr>
<tr class="separator:ab9c50cb423847e2024a9bf9bf83ea6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad47cec1b53de6071ef865e553856ef4"><td class="memItemLeft" align="right" valign="top"><a id="aad47cec1b53de6071ef865e553856ef4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#aad47cec1b53de6071ef865e553856ef4">~AnyField</a> () noexcept</td></tr>
<tr class="memdesc:aad47cec1b53de6071ef865e553856ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default non-throw dtor. <br /></td></tr>
<tr class="separator:aad47cec1b53de6071ef865e553856ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c6211c5dce42649b09aa9964aaf580"><td class="memItemLeft" align="right" valign="top"><a id="a37c6211c5dce42649b09aa9964aaf580"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#a37c6211c5dce42649b09aa9964aaf580">swap</a> (<a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a37c6211c5dce42649b09aa9964aaf580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard swap function, just exchanges PIMPL instances. <br /></td></tr>
<tr class="separator:a37c6211c5dce42649b09aa9964aaf580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab05419cb141d81de4307b0b71441b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#a5ab05419cb141d81de4307b0b71441b7">reset</a> () noexcept</td></tr>
<tr class="memdesc:a5ab05419cb141d81de4307b0b71441b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores the <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> to a default initialized state.  <a href="classpluginplay_1_1any_1_1AnyField.html#a5ab05419cb141d81de4307b0b71441b7">More...</a><br /></td></tr>
<tr class="separator:a5ab05419cb141d81de4307b0b71441b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc3bdc6617173da9e66c64be1e12c47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#a6eedd962b805fe06bdba02abacb5cf96">rtti_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#aedc3bdc6617173da9e66c64be1e12c47">type</a> () const noexcept</td></tr>
<tr class="memdesc:aedc3bdc6617173da9e66c64be1e12c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the RTTI of the wrapped type.  <a href="classpluginplay_1_1any_1_1AnyField.html#aedc3bdc6617173da9e66c64be1e12c47">More...</a><br /></td></tr>
<tr class="separator:aedc3bdc6617173da9e66c64be1e12c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f3ba6bd3ea2191f585082a4d1213e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a47f3ba6bd3ea2191f585082a4d1213e6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#a47f3ba6bd3ea2191f585082a4d1213e6">is_convertible</a> () const noexcept</td></tr>
<tr class="memdesc:a47f3ba6bd3ea2191f585082a4d1213e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the wrapped value can be converted to the specified type.  <a href="classpluginplay_1_1any_1_1AnyField.html#a47f3ba6bd3ea2191f585082a4d1213e6">More...</a><br /></td></tr>
<tr class="separator:a47f3ba6bd3ea2191f585082a4d1213e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf38798ba4579e859acc186df1d6355"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#aebf38798ba4579e859acc186df1d6355">operator==</a> (const <a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:aebf38798ba4579e859acc186df1d6355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a value comparison on two <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> instances.  <a href="classpluginplay_1_1any_1_1AnyField.html#aebf38798ba4579e859acc186df1d6355">More...</a><br /></td></tr>
<tr class="separator:aebf38798ba4579e859acc186df1d6355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9979d0b65d295fb467ad1c1d181f68f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#a9979d0b65d295fb467ad1c1d181f68f2">are_equal</a> (const <a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a9979d0b65d295fb467ad1c1d181f68f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphically compares two <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> objects.  <a href="classpluginplay_1_1any_1_1AnyField.html#a9979d0b65d295fb467ad1c1d181f68f2">More...</a><br /></td></tr>
<tr class="separator:a9979d0b65d295fb467ad1c1d181f68f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2553c0789bcd232659dc56b6e60186d3"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#a2553c0789bcd232659dc56b6e60186d3">print</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a2553c0789bcd232659dc56b6e60186d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a string representation of the wrapped object to the stream.  <a href="classpluginplay_1_1any_1_1AnyField.html#a2553c0789bcd232659dc56b6e60186d3">More...</a><br /></td></tr>
<tr class="separator:a2553c0789bcd232659dc56b6e60186d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19637d3d7a4fecaff47ad6822077a4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#ab19637d3d7a4fecaff47ad6822077a4f">has_value</a> () const noexcept</td></tr>
<tr class="memdesc:ab19637d3d7a4fecaff47ad6822077a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> currently wrap a value?  <a href="classpluginplay_1_1any_1_1AnyField.html#ab19637d3d7a4fecaff47ad6822077a4f">More...</a><br /></td></tr>
<tr class="separator:ab19637d3d7a4fecaff47ad6822077a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add74670b0c356d7e80fd73362db8d1f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#add74670b0c356d7e80fd73362db8d1f6">owns_value</a> () const noexcept</td></tr>
<tr class="memdesc:add74670b0c356d7e80fd73362db8d1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> own the wrapped value?  <a href="classpluginplay_1_1any_1_1AnyField.html#add74670b0c356d7e80fd73362db8d1f6">More...</a><br /></td></tr>
<tr class="separator:add74670b0c356d7e80fd73362db8d1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe5c69cbc88290eba46e23dce7f4697"><td class="memTemplParams" colspan="2"><a id="a7fe5c69cbc88290eba46e23dce7f4697"></a>
template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:a7fe5c69cbc88290eba46e23dce7f4697"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>save</b> (Archive &amp;ar) const</td></tr>
<tr class="separator:a7fe5c69cbc88290eba46e23dce7f4697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccf5092fe9ad9d353f96670c511f506"><td class="memTemplParams" colspan="2"><a id="a1ccf5092fe9ad9d353f96670c511f506"></a>
template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:a1ccf5092fe9ad9d353f96670c511f506"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>load</b> (Archive &amp;ar)</td></tr>
<tr class="separator:a1ccf5092fe9ad9d353f96670c511f506"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad5b029613f61629a733cc59b59d3d123"><td class="memTemplParams" colspan="2">template&lt;typename T , typename AnyType &gt; </td></tr>
<tr class="memitem:ad5b029613f61629a733cc59b59d3d123"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#ad5b029613f61629a733cc59b59d3d123">any_cast</a> (AnyType &amp;&amp;)</td></tr>
<tr class="memdesc:ad5b029613f61629a733cc59b59d3d123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows any_cast to actually cast the <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a>.  <a href="classpluginplay_1_1any_1_1AnyField.html#ad5b029613f61629a733cc59b59d3d123">More...</a><br /></td></tr>
<tr class="separator:ad5b029613f61629a733cc59b59d3d123"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a7c8b3fd62771959eba125e8e342ae79f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#a7c8b3fd62771959eba125e8e342ae79f">operator!=</a> (const <a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;lhs, const <a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;rhs)</td></tr>
<tr class="memdesc:a7c8b3fd62771959eba125e8e342ae79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> instances are different.  <a href="classpluginplay_1_1any_1_1AnyField.html#a7c8b3fd62771959eba125e8e342ae79f">More...</a><br /></td></tr>
<tr class="separator:a7c8b3fd62771959eba125e8e342ae79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780362b9b1d5f8ff9b2b0f18f2d8a948"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#a780362b9b1d5f8ff9b2b0f18f2d8a948">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;any)</td></tr>
<tr class="memdesc:a780362b9b1d5f8ff9b2b0f18f2d8a948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows stream insertion of <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> instances.  <a href="classpluginplay_1_1any_1_1AnyField.html#a780362b9b1d5f8ff9b2b0f18f2d8a948">More...</a><br /></td></tr>
<tr class="separator:a780362b9b1d5f8ff9b2b0f18f2d8a948"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Wraps either an input or a result to a module. </p>
<p>The <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> class is responsible for type-erasure of inputs and results to/from modules. For the most part users of PluginPlay shouldn't need to deal directly with <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a>; however, it indirectly affects users on account of the restrictions it places on inputs/results. We have tried to keep those restrictions to a minimum. Presently the required properties in order for a type to be wrappable are:</p>
<ul>
<li>must be copyable</li>
<li>overload operator== to compare two instances for value equality</li>
<li>overlaod operator&lt; to define an ordering of two instances</li>
</ul>
<p>Optionally the type may:</p>
<ul>
<li>overload std::ostream::operator&lt;&lt; for printing the value.</li>
</ul>
<p><a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> defines default implementations for any optional properties the type does not satisfy. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa81faf61ea66dd872d350ba3277a0a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81faf61ea66dd872d350ba3277a0a6b">&#9670;&nbsp;</a></span>AnyField() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pluginplay::any::AnyField::AnyField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#a86b67b0e1045c23c6ddd967d19dbe81c">pimpl_pointer</a>&#160;</td>
          <td class="paramname"><em>pimpl</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> wrapping the provided value. </p>
<p>This ctor serves as both the default and value ctors. By default it will wrap a null value. If a user supplies a PIMPL containing a wrapped value then the <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> will instead wrap that value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pimpl</td><td>A pointer to the PIMPL which holds the wrapped value. Defaults to a null pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc108a8616b058bb379caae97e332271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc108a8616b058bb379caae97e332271">&#9670;&nbsp;</a></span>AnyField() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pluginplay::any::AnyField::AnyField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> by deep copying an existing instance. </p>
<p>This ctor will deep copy the value held inside <code>other</code>. In particular, this means that if <code>other</code> aliases its value the new <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> will hold a copy of the wrapped value, NOT an alias. If you want to avoid deep copying the wrapped value work with references/pointers to an <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> and/or use move construction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a></td><td>The instance we are copying.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem copying. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1deacd9e8f9c7fdc04c03c08791a241d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1deacd9e8f9c7fdc04c03c08791a241d">&#9670;&nbsp;</a></span>AnyField() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pluginplay::any::AnyField::AnyField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes the state from an already existing <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> instance. </p>
<p>This ctor creates a new instance whose state is the state of an already existing instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> instance whose state is being taken. After this call <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> will be in a default initialized state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9979d0b65d295fb467ad1c1d181f68f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9979d0b65d295fb467ad1c1d181f68f2">&#9670;&nbsp;</a></span>are_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pluginplay::any::AnyField::are_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polymorphically compares two <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> objects. </p>
<p>While <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> is not polymorphic, it's PIMPL is. The internal polymorphic comparison compares more than just the wrapped values it also compares how the values are held. So for example if one instance owns an instance of the integer 42 and another references the integer 42, this method will return false because one is wrapped by value and the other is wrapped by reference.</p>
<p>In general this function returns true if two <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> instances:</p><ul>
<li>agree on the result of <code>has_value</code></li>
<li>hold their wrapped values the same way (e.g. by ref, by const ref)</li>
<li>the wrapped values compare equal</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>True if this <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> instance is "polymorphically" value equal to <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab19637d3d7a4fecaff47ad6822077a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19637d3d7a4fecaff47ad6822077a4f">&#9670;&nbsp;</a></span>has_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pluginplay::any::AnyField::has_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> currently wrap a value? </p>
<p>At any time an <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> either wraps a value or does not. This function is used to determine if the <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> wraps a value. Whether the <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> owns the value is not considered.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the PIMPL is non-null and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47f3ba6bd3ea2191f585082a4d1213e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f3ba6bd3ea2191f585082a4d1213e6">&#9670;&nbsp;</a></span>is_convertible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pluginplay::any::AnyField::is_convertible</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the wrapped value can be converted to the specified type. </p>
<p>Assuming the present instance wraps a value (if it does not this method will always return false) this method determines if a call to <code>any_cast&lt;T&gt;(*this)</code> will succeed. It should be noted that <code>T</code> should be cv and reference qualified, i.e., this method takes into account the <code>const</code>-ness and reference-semantics of <code>T</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A cv and reference qualified type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it is possible to convert the wrapped object to an instance of type <code>T</code> and false otherwise. Notably, if this instance does not contain a PIMPL this method returns false.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9c50cb423847e2024a9bf9bf83ea6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c50cb423847e2024a9bf9bf83ea6bb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp; pluginplay::any::AnyField::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the existing state with another <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a>'s state. </p>
<p>This method takes the state from <code>rhs</code>, sets the current instance to the taken state, and then releases the instance's old state. After this call any references/pointers to this instance's previous state are invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a></td><td>The instance we are taking the state from. After this call <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> will be in a default constructed state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance, after overwriting its state.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem copying. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0a93a22fb33a20a06b20b7395c3c308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a93a22fb33a20a06b20b7395c3c308">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp; pluginplay::any::AnyField::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the existing state with a deep copy of another <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a>. </p>
<p>This method deep copies the state of <code>rhs</code>, sets the current instance to the copied state, and then releases the instance's old state. After this call any references/pointers to the previous state are invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a></td><td>The instance we are copying.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance, after overwriting its state.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem copying. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebf38798ba4579e859acc186df1d6355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf38798ba4579e859acc186df1d6355">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pluginplay::any::AnyField::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a value comparison on two <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> instances. </p>
<p>This method first compares whether the two instances both wrap values, then (assumign they do wrap values) comparse the wrapped values. These comparisons ignore how the value is held. So for example if one instance owns an instance of the integer 42 and another references the integer 42, this method will return true even though one holds it by value and the other wraps a reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> instance we ware comparing against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the wrapped values are value equal and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add74670b0c356d7e80fd73362db8d1f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add74670b0c356d7e80fd73362db8d1f6">&#9670;&nbsp;</a></span>owns_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pluginplay::any::AnyField::owns_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> own the wrapped value? </p>
<p>When <code><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#ab19637d3d7a4fecaff47ad6822077a4f" title="Does this AnyField currently wrap a value?">has_value()</a></code> is true this instance wraps a value. The instance may actually own the value it wraps (for example it copied the value at construction) or it may alias it (was given a reference to the value). This method will return true if this instance owns the value it wraps. In particular, <code><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#add74670b0c356d7e80fd73362db8d1f6" title="Does the AnyField own the wrapped value?">owns_value()</a></code> equals true means that the wrapped object will exist as long as this instance exists, and conversely that if the aliased value goes out of scope, this instance will contain a dangling reference.</p>
<p>To create an owning instance from one that does not own, copy it.</p>
<dl class="section note"><dt>Note</dt><dd>Instances holding Python objects own them. This is because unwrapping Python objects requires creating a C++ object in a buffer and the buffer will be owned by *this. Even if the Python object is not unwrapped, we hold a reference counted instance and thus it will not go out of scope, consistent with the C++ behavior of this method.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if this instance wraps a value, and it owns that value. False otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2553c0789bcd232659dc56b6e60186d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2553c0789bcd232659dc56b6e60186d3">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; pluginplay::any::AnyField::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a string representation of the wrapped object to the stream. </p>
<p>Sometimes it's useful to have string representations of objects. If the wrapped object overloads std::ostream::operator&lt;&lt; this function will use std::ostream::operator&lt;&lt; to add a string representation of the wrapped object to <code>os</code>. If no such overload is present, the type and address of the object will be printed as a proxy representation. Finally, if this <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> is not presently holding a value <code>os</code> will be returned unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">os</td><td>The stream we are printing to. After this operation <code>os</code> will contain a string representation of the wrapped value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> after adding the string representation to it.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the wrapped object's operator&lt;&lt; throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ab05419cb141d81de4307b0b71441b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab05419cb141d81de4307b0b71441b7">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::any::AnyField::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restores the <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> to a default initialized state. </p>
<p>This method can be used to release the held pointer. For instances which own their wrapped value, this will delete the wrapped value. For instances which only alias their value, this will only release the handle to the original value, i.e. the original value will continue to exist. If the current <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> instance does not hold a value this is a no-op.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedc3bdc6617173da9e66c64be1e12c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc3bdc6617173da9e66c64be1e12c47">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1any_1_1AnyField.html#a6eedd962b805fe06bdba02abacb5cf96">AnyField::rtti_type</a> pluginplay::any::AnyField::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the RTTI of the wrapped type. </p>
<p>At any given time an <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> either wraps a value or does not. If it wraps a value this function will return the RTTI of the wrapped value. If it does not wrap a type, it will return the RTTI of a nullptr.</p>
<p>N.B. the RTTI does not take into account cv-qualifiers or references.</p>
<dl class="section return"><dt>Returns</dt><dd>The RTTI of the wrapped value, if has_value is true. Otherwise the RTTI of a nullptr will be returned.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ad5b029613f61629a733cc59b59d3d123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b029613f61629a733cc59b59d3d123">&#9670;&nbsp;</a></span>any_cast</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename AnyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T any_cast </td>
          <td>(</td>
          <td class="paramtype">AnyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>da_any</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows any_cast to actually cast the <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The qualified type (i.e. including cv-qualifiers and references) to return. </td></tr>
    <tr><td class="paramname">AnyType</td><td>The type of the type-erased object we are unwrapping. Expected to be a type such that std::deacy_t&lt;AnyType&gt; is <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This free function is used to unwrap an AnyAnyField. To avoid unnecessary copies users need to fully specify the type of object to unwrap. In many cases <code>T</code> should be something like <code>const U&amp;</code> where <code>U</code> is an unqualified type (this example would return a read-only reference to an instance of type <code>U</code>). Assuming a wrapped object of type <code>U</code> it is always possible for <code>T</code> to be:</p>
<ul>
<li><code>std::decay_t&lt;U&gt;</code> (by copy)</li>
<li><code>const std::decay_t&lt;U&gt;</code> (by read-only copy)</li>
<li><code>const std::decay_t&lt;U&gt;&amp;</code> (by read-only reference)</li>
</ul>
<p>Additionally, for AnyFields which own non-const values, one can retrieve modifiable references, i.e. <code>T = std::decay_t&lt;u&gt;&amp;</code> is also allowed.</p>
<p>Conversions which are not allowed will either trip static assertions or result in this function throwing <code>std::runtime_error</code> depending on whether or not we know at compile time if a conversion is allowed. Attempting to unwrap anything other than an <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> will also lead to a static assertion being tripped.</p>
<dl class="section note"><dt>Note</dt><dd>It is not possible to move a mutable value out of an <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> at this time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">da_any</td><td>The type-erased value we are unwrapping.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The object wrapped in <code>da_any</code> as an instance of type <code>T</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>da_any</code> does not currently wrap a value. Strong throw guarantee.</td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the wrapped object can not be returned as an instance of type <code>T</code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c8b3fd62771959eba125e8e342ae79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8b3fd62771959eba125e8e342ae79f">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> instances are different. </p>
<p>Two <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> instances are different if operator== returns false. This function simply negates the result of operator==. See operator== for the definition of equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> on the left of the operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> on the right of the operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if lhs == rhs, and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a780362b9b1d5f8ff9b2b0f18f2d8a948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780362b9b1d5f8ff9b2b0f18f2d8a948">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1any_1_1AnyField.html">AnyField</a> &amp;&#160;</td>
          <td class="paramname"><em>any</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows stream insertion of <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> instances. </p>
<p>This function overloads std::ostream::operator&lt;&lt; so that <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> instances can be inserted into std::ostream instances. The actual implementation simply defers to <a class="el" href="classpluginplay_1_1any_1_1AnyField.html#a2553c0789bcd232659dc56b6e60186d3" title="Adds a string representation of the wrapped object to the stream.">AnyField::print</a>. More details on the insertion behavior can be found in the documentation for <a class="el" href="classpluginplay_1_1any_1_1AnyField.html#a2553c0789bcd232659dc56b6e60186d3" title="Adds a string representation of the wrapped object to the stream.">AnyField::print</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">os</td><td>The stream we are inserting <code>any</code> in to. After this call <code>os</code> will contain a string representation of <code>any</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">any</td><td>The <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> instance we are inserting into <code>os</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> after inserting <code>any</code> in to it.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If <a class="el" href="classpluginplay_1_1any_1_1AnyField.html#a2553c0789bcd232659dc56b6e60186d3" title="Adds a string representation of the wrapped object to the stream.">AnyField::print</a> throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/pluginplay/any/<a class="el" href="any__field_8hpp_source.html">any_field.hpp</a></li>
<li>src/pluginplay/any/any_field.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
