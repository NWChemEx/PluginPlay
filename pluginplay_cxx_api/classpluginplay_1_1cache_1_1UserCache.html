<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>pluginplay: pluginplay::cache::UserCache Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">pluginplay
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pluginplay</b></li><li class="navelem"><b>cache</b></li><li class="navelem"><a class="el" href="classpluginplay_1_1cache_1_1UserCache.html">UserCache</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpluginplay_1_1cache_1_1UserCache-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pluginplay::cache::UserCache Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A place for users to store intermediate module artifacts.  
 <a href="classpluginplay_1_1cache_1_1UserCache.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="user__cache_8hpp_source.html">user_cache.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af44acc631efeae88b3f140aae233e261"><td class="memItemLeft" align="right" valign="top"><a id="af44acc631efeae88b3f140aae233e261"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1cache_1_1UserCache.html#af44acc631efeae88b3f140aae233e261">sub_cache_type</a> = <a class="el" href="classpluginplay_1_1cache_1_1ModuleCache.html">ModuleCache</a></td></tr>
<tr class="memdesc:af44acc631efeae88b3f140aae233e261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to implement the <a class="el" href="classpluginplay_1_1cache_1_1UserCache.html" title="A place for users to store intermediate module artifacts.">UserCache</a>. <br /></td></tr>
<tr class="separator:af44acc631efeae88b3f140aae233e261"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a29d7132d43603e64258e8c168bd61971"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1cache_1_1UserCache.html#a29d7132d43603e64258e8c168bd61971">UserCache</a> ()=default</td></tr>
<tr class="memdesc:a29d7132d43603e64258e8c168bd61971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a default initialized <a class="el" href="classpluginplay_1_1cache_1_1UserCache.html" title="A place for users to store intermediate module artifacts.">UserCache</a>.  <a href="classpluginplay_1_1cache_1_1UserCache.html#a29d7132d43603e64258e8c168bd61971">More...</a><br /></td></tr>
<tr class="separator:a29d7132d43603e64258e8c168bd61971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8bee66a1dd0f101cffb37877acd813"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1cache_1_1UserCache.html#a0c8bee66a1dd0f101cffb37877acd813">UserCache</a> (<a class="el" href="classpluginplay_1_1cache_1_1UserCache.html#af44acc631efeae88b3f140aae233e261">sub_cache_type</a> <a class="el" href="classpluginplay_1_1cache_1_1UserCache.html#a2a26bb0d719515e39ae8c29689014f6c">cache</a>)</td></tr>
<tr class="memdesc:a0c8bee66a1dd0f101cffb37877acd813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classpluginplay_1_1cache_1_1UserCache.html" title="A place for users to store intermediate module artifacts.">UserCache</a> that uses <code>cache</code> for the implementation.  <a href="classpluginplay_1_1cache_1_1UserCache.html#a0c8bee66a1dd0f101cffb37877acd813">More...</a><br /></td></tr>
<tr class="separator:a0c8bee66a1dd0f101cffb37877acd813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045d327528b552f2f4f857af6876e14c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a045d327528b552f2f4f857af6876e14c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1cache_1_1UserCache.html#a045d327528b552f2f4f857af6876e14c">count</a> (T &amp;&amp;key) const</td></tr>
<tr class="memdesc:a045d327528b552f2f4f857af6876e14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>key</code> appears in the cache or not.  <a href="classpluginplay_1_1cache_1_1UserCache.html#a045d327528b552f2f4f857af6876e14c">More...</a><br /></td></tr>
<tr class="separator:a045d327528b552f2f4f857af6876e14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a26bb0d719515e39ae8c29689014f6c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a2a26bb0d719515e39ae8c29689014f6c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1cache_1_1UserCache.html#a2a26bb0d719515e39ae8c29689014f6c">cache</a> (T &amp;&amp;key, U &amp;&amp;value)</td></tr>
<tr class="memdesc:a2a26bb0d719515e39ae8c29689014f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the provided key/value pair to the cache.  <a href="classpluginplay_1_1cache_1_1UserCache.html#a2a26bb0d719515e39ae8c29689014f6c">More...</a><br /></td></tr>
<tr class="separator:a2a26bb0d719515e39ae8c29689014f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f1ee692cff0d1e03f4df3fef606f15"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T &gt; </td></tr>
<tr class="memitem:a89f1ee692cff0d1e03f4df3fef606f15"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1cache_1_1UserCache.html#a89f1ee692cff0d1e03f4df3fef606f15">uncache</a> (T &amp;&amp;key)</td></tr>
<tr class="memdesc:a89f1ee692cff0d1e03f4df3fef606f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a cached value.  <a href="classpluginplay_1_1cache_1_1UserCache.html#a89f1ee692cff0d1e03f4df3fef606f15">More...</a><br /></td></tr>
<tr class="separator:a89f1ee692cff0d1e03f4df3fef606f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b368f16aeb2d7c0c17d5c605d2b7ca"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T , typename V &gt; </td></tr>
<tr class="memitem:a96b368f16aeb2d7c0c17d5c605d2b7ca"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1cache_1_1UserCache.html#a96b368f16aeb2d7c0c17d5c605d2b7ca">uncache</a> (T &amp;&amp;key, V &amp;&amp;default_value)</td></tr>
<tr class="memdesc:a96b368f16aeb2d7c0c17d5c605d2b7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncache with optional default value.  <a href="classpluginplay_1_1cache_1_1UserCache.html#a96b368f16aeb2d7c0c17d5c605d2b7ca">More...</a><br /></td></tr>
<tr class="separator:a96b368f16aeb2d7c0c17d5c605d2b7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0365990b8b18cebd6cbb0fd079f6d9a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1cache_1_1UserCache.html#a0365990b8b18cebd6cbb0fd079f6d9a4">reset_cache</a> ()</td></tr>
<tr class="memdesc:a0365990b8b18cebd6cbb0fd079f6d9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the contents of the cache.  <a href="classpluginplay_1_1cache_1_1UserCache.html#a0365990b8b18cebd6cbb0fd079f6d9a4">More...</a><br /></td></tr>
<tr class="separator:a0365990b8b18cebd6cbb0fd079f6d9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A place for users to store intermediate module artifacts. </p>
<p>Sometimes users need to store results betweeen calls to a module. For example many iterative modules may require knowledge of prior guesses in order to produce a new guess. <a class="el" href="classpluginplay_1_1cache_1_1UserCache.html" title="A place for users to store intermediate module artifacts.">UserCache</a> objects are a place where users can put these intermediate results and still have them be part of the broader cache. Users need to be careful to tag stored results in a manner that ties them back to the inputs that generated them as subsequent calls to the module are not necessarilly continuing the same calculation.</p>
<p>As an implementation note <a class="el" href="classpluginplay_1_1cache_1_1UserCache.html" title="A place for users to store intermediate module artifacts.">UserCache</a> instances just wrap <a class="el" href="classpluginplay_1_1cache_1_1ModuleCache.html" title="Class storing the memoized results for a particular module implementation.">ModuleCache</a> instances (although they are distict <a class="el" href="classpluginplay_1_1cache_1_1ModuleCache.html" title="Class storing the memoized results for a particular module implementation.">ModuleCache</a> instance from the one the module uses for memoization). The <a class="el" href="classpluginplay_1_1cache_1_1UserCache.html" title="A place for users to store intermediate module artifacts.">UserCache</a> simply type-erases the inputs and results its given and feeds them into the underlying <a class="el" href="classpluginplay_1_1cache_1_1ModuleCache.html" title="Class storing the memoized results for a particular module implementation.">ModuleCache</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a29d7132d43603e64258e8c168bd61971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d7132d43603e64258e8c168bd61971">&#9670;&nbsp;</a></span>UserCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pluginplay::cache::UserCache::UserCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a default initialized <a class="el" href="classpluginplay_1_1cache_1_1UserCache.html" title="A place for users to store intermediate module artifacts.">UserCache</a>. </p>
<p>Default constructed <a class="el" href="classpluginplay_1_1cache_1_1UserCache.html" title="A place for users to store intermediate module artifacts.">UserCache</a> instances contain default initialized state and thus can not actually be used for cacheing/uncacheing. In practice users get <a class="el" href="classpluginplay_1_1cache_1_1UserCache.html" title="A place for users to store intermediate module artifacts.">UserCache</a> instances from an existing <a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html" title="&quot;The Cache&quot;. This object holds all of the data the ModuleManager needs to cache.">ModuleManagerCache</a> instance and the default ctor serves primarily as a means of creating placeholder instances.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c8bee66a1dd0f101cffb37877acd813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8bee66a1dd0f101cffb37877acd813">&#9670;&nbsp;</a></span>UserCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pluginplay::cache::UserCache::UserCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpluginplay_1_1cache_1_1UserCache.html#af44acc631efeae88b3f140aae233e261">sub_cache_type</a>&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classpluginplay_1_1cache_1_1UserCache.html" title="A place for users to store intermediate module artifacts.">UserCache</a> that uses <code>cache</code> for the implementation. </p>
<p><a class="el" href="classpluginplay_1_1cache_1_1UserCache.html" title="A place for users to store intermediate module artifacts.">UserCache</a> instances are typically created by <a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html" title="&quot;The Cache&quot;. This object holds all of the data the ModuleManager needs to cache.">ModuleManagerCache</a> instances. This is the ctor that the <a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html" title="&quot;The Cache&quot;. This object holds all of the data the ModuleManager needs to cache.">ModuleManagerCache</a> instance uses to create the <a class="el" href="classpluginplay_1_1cache_1_1UserCache.html" title="A place for users to store intermediate module artifacts.">UserCache</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cache</td><td>A <a class="el" href="classpluginplay_1_1cache_1_1ModuleCache.html" title="Class storing the memoized results for a particular module implementation.">ModuleCache</a> instance. The resulting <a class="el" href="classpluginplay_1_1cache_1_1UserCache.html" title="A place for users to store intermediate module artifacts.">UserCache</a> will be implemented by wrapping the provided <a class="el" href="classpluginplay_1_1cache_1_1ModuleCache.html" title="Class storing the memoized results for a particular module implementation.">ModuleCache</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2a26bb0d719515e39ae8c29689014f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a26bb0d719515e39ae8c29689014f6c">&#9670;&nbsp;</a></span>cache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::cache::UserCache::cache </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the provided key/value pair to the cache. </p>
<p>This method is used to store a key/value pair in the user cache. Callers should be aware that the next call to their module is not necessarilly continuing the calculation and sshould choose <code>key</code> appropriately so as to avoid collisions.</p>
<p>N.B. Callers can use std::tuple to use multiple objects as a key or a value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of <code>key</code>. Must be type-erasable to an AnyField. </td></tr>
    <tr><td class="paramname">U</td><td>The type of <code>value</code>. Must be type-erasable to an AnyField.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The object used to tag the result. It is the caller's responsibilty to make sure <code>key</code> is unique to the inputs which generated the result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The object to associate with <code>key</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the wrapped <a class="el" href="classpluginplay_1_1cache_1_1ModuleCache.html" title="Class storing the memoized results for a particular module implementation.">ModuleCache</a> is default initialized. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a045d327528b552f2f4f857af6876e14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045d327528b552f2f4f857af6876e14c">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pluginplay::cache::UserCache::count </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>key</code> appears in the cache or not. </p>
<p><a class="el" href="classpluginplay_1_1Module.html" title="The public API of all modules.">Module</a> developers are allowed to cache their module's state in the provided <a class="el" href="classpluginplay_1_1cache_1_1UserCache.html" title="A place for users to store intermediate module artifacts.">UserCache</a>. When they do this it's through a key/value API. This method allows the caller to determine if a value has been cached under the provided key.</p>
<p>N.B. The actual look up of the key is done in a type-erased manner that is slightly sensitive to the type of <code>key</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of <code>key</code>. <code>T</code> will be determined by the compiler. In rare cases the caller may want to specify <code>T</code> to ensure <code>key</code> gets passed as the correct type. For example string literals are not the same thing as <code>std::string</code>. <code>T</code> must be type-erasable to an AnyField.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there are results cached under <code>key</code> and false otherwise. </dd></dl>

</div>
</div>
<a id="a0365990b8b18cebd6cbb0fd079f6d9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0365990b8b18cebd6cbb0fd079f6d9a4">&#9670;&nbsp;</a></span>reset_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::cache::UserCache::reset_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the contents of the cache. </p>
<dl class="section warning"><dt>Warning</dt><dd>Calling this member will delete the cached results. No attempt at long-term archival of the results will be made.</dd></dl>
<p>This method is used to clear out the current cache. More specifically calling this method will release all memory held by the already cached entries. No attempt will be made to move the cached entries to a long- term archival medium before the clear is done.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>Throws if the backend throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89f1ee692cff0d1e03f4df3fef606f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f1ee692cff0d1e03f4df3fef606f15">&#9670;&nbsp;</a></span>uncache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">U pluginplay::cache::UserCache::uncache </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a cached value. </p>
<p>This method is used to reverse the cache call. On account of the type- erasure used to insert the value, this method requires the caller to specify the type of the object they want to get back.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the object that was cached under <code>key</code>. This parameter must be specified by the caller. </td></tr>
    <tr><td class="paramname">T</td><td>The type of <code>key</code>. <code>T</code> must be type-erasable to an AnyField.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The object which was associated with the value we want.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value that was cached under <code>key</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a value cached under <code>key</code>, but it can not be implicitly converted to type <code>U</code>. </td></tr>
    <tr><td class="paramname">std::out_of_range</td><td>if there is no value cached under <code>key</code> or if this instance contains a default initialized <a class="el" href="classpluginplay_1_1cache_1_1ModuleCache.html" title="Class storing the memoized results for a particular module implementation.">ModuleCache</a>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96b368f16aeb2d7c0c17d5c605d2b7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b368f16aeb2d7c0c17d5c605d2b7ca">&#9670;&nbsp;</a></span>uncache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename T , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">U pluginplay::cache::UserCache::uncache </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uncache with optional default value. </p>
<p>This method checks to see if there's a result cached under <code>key</code>. If so that result is returned. If not, then <code>default_value</code> is returned. This is largely intended as code factorization for the very common use case when you attempt to restart from a cached result, but need to use a default value if no cached result exists.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the result. Results are stored in a type-erased manner so you must know the result's type to uncache it. </td></tr>
    <tr><td class="paramname">T</td><td>The type of the key. </td></tr>
    <tr><td class="paramname">V</td><td>The type of the default argument. Must be implicitly convertible to type U.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The object used to store the result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_value</td><td>The value to return if there is no result stored under <code>key</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result stored under <code>key</code> (if there is one) otherwise <code>default_value</code> is returned. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/pluginplay/cache/<a class="el" href="user__cache_8hpp_source.html">user_cache.hpp</a></li>
<li>include/pluginplay/cache/user_cache.ipp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
