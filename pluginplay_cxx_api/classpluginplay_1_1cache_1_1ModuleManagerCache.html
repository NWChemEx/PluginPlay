<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>pluginplay: pluginplay::cache::ModuleManagerCache Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">pluginplay
   &#160;<span id="projectnumber">1.0.32</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pluginplay</b></li><li class="navelem"><b>cache</b></li><li class="navelem"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html">ModuleManagerCache</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpluginplay_1_1cache_1_1ModuleManagerCache-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pluginplay::cache::ModuleManagerCache Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>"The Cache". This object holds all of the data the <a class="el" href="classpluginplay_1_1ModuleManager.html" title="Class responsible for manipulating.">ModuleManager</a> needs to cache.  
 <a href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="module__manager__cache_8hpp_source.html">module_manager_cache.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:add7300eb5f8d7fa2f82bbb8112deb84a"><td class="memItemLeft" align="right" valign="top"><a id="add7300eb5f8d7fa2f82bbb8112deb84a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#add7300eb5f8d7fa2f82bbb8112deb84a">module_cache_key</a> = std::string</td></tr>
<tr class="memdesc:add7300eb5f8d7fa2f82bbb8112deb84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the object used as keys for module (and user) caches. <br /></td></tr>
<tr class="separator:add7300eb5f8d7fa2f82bbb8112deb84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e191483fe4ce1c685c398dd0872a199"><td class="memItemLeft" align="right" valign="top"><a id="a3e191483fe4ce1c685c398dd0872a199"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#a3e191483fe4ce1c685c398dd0872a199">path_type</a> = std::string</td></tr>
<tr class="memdesc:a3e191483fe4ce1c685c398dd0872a199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of object users should use to specify directory paths. <br /></td></tr>
<tr class="separator:a3e191483fe4ce1c685c398dd0872a199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bd4a769e37c539ee76355ed6931ecd"><td class="memItemLeft" align="right" valign="top"><a id="a72bd4a769e37c539ee76355ed6931ecd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#a72bd4a769e37c539ee76355ed6931ecd">module_cache_type</a> = <a class="el" href="classpluginplay_1_1cache_1_1ModuleCache.html">ModuleCache</a></td></tr>
<tr class="memdesc:a72bd4a769e37c539ee76355ed6931ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the per-module cache, this cache is used for memoization. <br /></td></tr>
<tr class="separator:a72bd4a769e37c539ee76355ed6931ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5804ce2308b02f12ea2e117a0474b01e"><td class="memItemLeft" align="right" valign="top"><a id="a5804ce2308b02f12ea2e117a0474b01e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#a5804ce2308b02f12ea2e117a0474b01e">module_cache_pointer</a> = std::shared_ptr&lt; <a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#a72bd4a769e37c539ee76355ed6931ecd">module_cache_type</a> &gt;</td></tr>
<tr class="memdesc:a5804ce2308b02f12ea2e117a0474b01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a shared pointer to a per-module cache. <br /></td></tr>
<tr class="separator:a5804ce2308b02f12ea2e117a0474b01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9044cfc0c9b25864e6f71e3f0be03b67"><td class="memItemLeft" align="right" valign="top"><a id="a9044cfc0c9b25864e6f71e3f0be03b67"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#a9044cfc0c9b25864e6f71e3f0be03b67">user_cache_type</a> = <a class="el" href="classpluginplay_1_1cache_1_1UserCache.html">UserCache</a></td></tr>
<tr class="memdesc:a9044cfc0c9b25864e6f71e3f0be03b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the cache that module developers can store state in. <br /></td></tr>
<tr class="separator:a9044cfc0c9b25864e6f71e3f0be03b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed559b2e9470904aa9a7b6f7e6462b45"><td class="memItemLeft" align="right" valign="top"><a id="aed559b2e9470904aa9a7b6f7e6462b45"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#aed559b2e9470904aa9a7b6f7e6462b45">user_cache_pointer</a> = std::shared_ptr&lt; <a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#a9044cfc0c9b25864e6f71e3f0be03b67">user_cache_type</a> &gt;</td></tr>
<tr class="memdesc:aed559b2e9470904aa9a7b6f7e6462b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a shared pointer to a user_cache_type object. <br /></td></tr>
<tr class="separator:aed559b2e9470904aa9a7b6f7e6462b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e8111516d34a334fd57db1369b21151"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#a3e8111516d34a334fd57db1369b21151">ModuleManagerCache</a> () noexcept</td></tr>
<tr class="memdesc:a3e8111516d34a334fd57db1369b21151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new instance that does not save to disk.  <a href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#a3e8111516d34a334fd57db1369b21151">More...</a><br /></td></tr>
<tr class="separator:a3e8111516d34a334fd57db1369b21151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8615830d408b145f792863ed8a110f01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#a8615830d408b145f792863ed8a110f01">ModuleManagerCache</a> (<a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#a3e191483fe4ce1c685c398dd0872a199">path_type</a> disk_location)</td></tr>
<tr class="memdesc:a8615830d408b145f792863ed8a110f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new instance which does save to disk.  <a href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#a8615830d408b145f792863ed8a110f01">More...</a><br /></td></tr>
<tr class="separator:a8615830d408b145f792863ed8a110f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdaf0579be72e9088cfb475df9993969"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#afdaf0579be72e9088cfb475df9993969">~ModuleManagerCache</a> () noexcept</td></tr>
<tr class="memdesc:afdaf0579be72e9088cfb475df9993969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default dtor.  <a href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#afdaf0579be72e9088cfb475df9993969">More...</a><br /></td></tr>
<tr class="separator:afdaf0579be72e9088cfb475df9993969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aca933b469247b0b0136e5cf677c899"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#a2aca933b469247b0b0136e5cf677c899">change_save_location</a> (<a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#a3e191483fe4ce1c685c398dd0872a199">path_type</a> disk_location)</td></tr>
<tr class="memdesc:a2aca933b469247b0b0136e5cf677c899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes/sets the disk location where the cache is backed up to.  <a href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#a2aca933b469247b0b0136e5cf677c899">More...</a><br /></td></tr>
<tr class="separator:a2aca933b469247b0b0136e5cf677c899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86d52e9488d2b9c1a6545d9c4fdec2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#a5804ce2308b02f12ea2e117a0474b01e">module_cache_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#ad86d52e9488d2b9c1a6545d9c4fdec2d">get_or_make_module_cache</a> (<a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#add7300eb5f8d7fa2f82bbb8112deb84a">module_cache_key</a> key)</td></tr>
<tr class="memdesc:ad86d52e9488d2b9c1a6545d9c4fdec2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the module cache for <code>key</code>.  <a href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#ad86d52e9488d2b9c1a6545d9c4fdec2d">More...</a><br /></td></tr>
<tr class="separator:ad86d52e9488d2b9c1a6545d9c4fdec2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c219c22e068659fb9ff661f8dddbba4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#aed559b2e9470904aa9a7b6f7e6462b45">user_cache_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#a3c219c22e068659fb9ff661f8dddbba4">get_or_make_user_cache</a> (<a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#add7300eb5f8d7fa2f82bbb8112deb84a">module_cache_key</a> key)</td></tr>
<tr class="memdesc:a3c219c22e068659fb9ff661f8dddbba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the requested user cache.  <a href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#a3c219c22e068659fb9ff661f8dddbba4">More...</a><br /></td></tr>
<tr class="separator:a3c219c22e068659fb9ff661f8dddbba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>"The Cache". This object holds all of the data the <a class="el" href="classpluginplay_1_1ModuleManager.html" title="Class responsible for manipulating.">ModuleManager</a> needs to cache. </p>
<p>For convenience PluginPlay defines a single cache object. This cache object encapsulates all of the data that needs to be saved/loaded for whatever reason. The <a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html" title="&quot;The Cache&quot;. This object holds all of the data the ModuleManager needs to cache.">ModuleManagerCache</a> is this single cache. Each <a class="el" href="classpluginplay_1_1ModuleManager.html" title="Class responsible for manipulating.">ModuleManager</a> instance has one <a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html" title="&quot;The Cache&quot;. This object holds all of the data the ModuleManager needs to cache.">ModuleManagerCache</a> internally.</p>
<p>Notes on parallel behavior:</p>
<p>This class is relatively ignorant of parallelism. What this means is that much of its internals do not do anything special in a parallel enviornment; however, this should be fine. In particular:</p>
<ul>
<li>the cache always uses process local memory (synchrnoization can be added later, but most initial usecases have SIMD interactions with modules)</li>
<li>whether each process writes to a local disk or a common location is determined by the directory path given to the instance. In general it is the user's responsibility to choose whether all the processes see the same cache (for example by providing a path on a parallel filesystem), or if there multiple caches (for example by providing paths that are only visible to a proper subset of processes).</li>
<li>in most cases functions are not thread-safe. For memoization this may lead to cache-misses on account of data races (e.g., thread 1 is computing, but hasn't cached a result that thread 2 is looking for. The result is thread 2 will duplicate the effort, but otherwise there's no harm done). </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3e8111516d34a334fd57db1369b21151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8111516d34a334fd57db1369b21151">&#9670;&nbsp;</a></span>ModuleManagerCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pluginplay::cache::ModuleManagerCache::ModuleManagerCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new instance that does not save to disk. </p>
<p>Default created <a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html" title="&quot;The Cache&quot;. This object holds all of the data the ModuleManager needs to cache.">ModuleManagerCache</a> instances have no state and will store their cached results in memory, with no option of backing up to disk. Users can enable disk backups by calling change_save_location on a <a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html" title="&quot;The Cache&quot;. This object holds all of the data the ModuleManager needs to cache.">ModuleManagerCache</a> instance. . </p>

</div>
</div>
<a id="a8615830d408b145f792863ed8a110f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8615830d408b145f792863ed8a110f01">&#9670;&nbsp;</a></span>ModuleManagerCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pluginplay::cache::ModuleManagerCache::ModuleManagerCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#a3e191483fe4ce1c685c398dd0872a199">path_type</a>&#160;</td>
          <td class="paramname"><em>disk_location</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new instance which does save to disk. </p>
<p>This ctor is used for both loading existing caches from disk and creating new caches which can save to disk. If <code>disk_location</code> points to a directory that does not exist, that directory will be created and used for saving the cache (the cache actually consists of multiple files which is why it is a directory and not a file). If <code>disk_location</code> already exists then we assume you want us to reuse the cache that already lives at <code>disk_location</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">disk_location</td><td>The (ideally full) path to the directory where cached results will be saved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdaf0579be72e9088cfb475df9993969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdaf0579be72e9088cfb475df9993969">&#9670;&nbsp;</a></span>~ModuleManagerCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pluginplay::cache::ModuleManagerCache::~ModuleManagerCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default dtor. </p>
<p>This desctructor simply cleans up the memory. In particular it does not force a save or anything like that.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2aca933b469247b0b0136e5cf677c899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aca933b469247b0b0136e5cf677c899">&#9670;&nbsp;</a></span>change_save_location()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::cache::ModuleManagerCache::change_save_location </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#a3e191483fe4ce1c685c398dd0872a199">path_type</a>&#160;</td>
          <td class="paramname"><em>disk_location</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes/sets the disk location where the cache is backed up to. </p>
<p>If you want the cache to be saved to disk it is strongly advised you use the ctor which takes a path. That said, you can use this method to make it such that future get_or_make calls create/load caches from a disk-based location. In particular, this will not affect caches which have been created by this instance prior to calling change_save_location (i.e., if you made some in memory-only caches, this method will not reallocate them/migrate their data to a cache which can save to disk).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">disk_location</td><td>Where the cache should be saved to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad86d52e9488d2b9c1a6545d9c4fdec2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86d52e9488d2b9c1a6545d9c4fdec2d">&#9670;&nbsp;</a></span>get_or_make_module_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#a5804ce2308b02f12ea2e117a0474b01e">ModuleManagerCache::module_cache_pointer</a> pluginplay::cache::ModuleManagerCache::get_or_make_module_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#add7300eb5f8d7fa2f82bbb8112deb84a">module_cache_key</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the module cache for <code>key</code>. </p>
<p>For module implementations which can be memoized, the cache holds a module cache instance for this purpose. That cache is shared by all instances of that implementation. It is the caller's responsibility to assign unique identifiers to each different module implementation.</p>
<p>This function is used to retrieve the module cache for the module associated with <code>key</code>. If the cache does not exist prior to this call it will be created and then returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The identifier for the specific module implementation whose module cache we are to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the requested module cache.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the cache does not already exist and there is a problem allocating it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c219c22e068659fb9ff661f8dddbba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c219c22e068659fb9ff661f8dddbba4">&#9670;&nbsp;</a></span>get_or_make_user_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#aed559b2e9470904aa9a7b6f7e6462b45">ModuleManagerCache::user_cache_pointer</a> pluginplay::cache::ModuleManagerCache::get_or_make_user_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpluginplay_1_1cache_1_1ModuleManagerCache.html#add7300eb5f8d7fa2f82bbb8112deb84a">module_cache_key</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the requested user cache. </p>
<p><a class="el" href="classpluginplay_1_1Module.html" title="The public API of all modules.">Module</a> developers may need to cache internal state. To do this PluginPlay associates with each module implementation a user cache. Like the module cache, the user cache is shared by all isntances of the same algorithm.</p>
<p>This method retrieves the user cache associated with <code>key</code>. If the cache does not exist prior to this call it will be created and then returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The identifier for the specific module implementation whose user cache we are to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the requested user cache.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the cache does not already exist and there is a problem allocating it. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/pluginplay/cache/<a class="el" href="module__manager__cache_8hpp_source.html">module_manager_cache.hpp</a></li>
<li>src/pluginplay/cache/module_manager_cache.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
