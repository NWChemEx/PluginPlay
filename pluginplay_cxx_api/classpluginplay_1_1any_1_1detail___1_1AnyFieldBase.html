<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>pluginplay: pluginplay::any::detail_::AnyFieldBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">pluginplay<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pluginplay</b></li><li class="navelem"><b>any</b></li><li class="navelem"><b>detail_</b></li><li class="navelem"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html">AnyFieldBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">pluginplay::any::detail_::AnyFieldBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for pluginplay::any::detail_::AnyFieldBase:</div>
<div class="dyncontent">
<div class="center"><img src="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase__inherit__graph.png" border="0" usemap="#apluginplay_1_1any_1_1detail___1_1AnyFieldBase_inherit__map" alt="Inheritance graph"/></div>
<map name="apluginplay_1_1any_1_1detail___1_1AnyFieldBase_inherit__map" id="apluginplay_1_1any_1_1detail___1_1AnyFieldBase_inherit__map">
<area shape="rect" title=" " alt="" coords="16,5,181,45"/>
<area shape="rect" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html" title="Given knowledge of type T, implements AnyFieldBase." alt="" coords="5,93,192,133"/>
<area shape="poly" title=" " alt="" coords="101,59,101,93,96,93,96,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a56f22739d8829d8fd736e452fb237d2c" id="r_a56f22739d8829d8fd736e452fb237d2c"><td class="memItemLeft" align="right" valign="top"><a id="a56f22739d8829d8fd736e452fb237d2c" name="a56f22739d8829d8fd736e452fb237d2c"></a>
<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>field_base_pointer</b> = std::unique_ptr&lt; <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html">AnyFieldBase</a> &gt;</td></tr>
<tr class="memdesc:a56f22739d8829d8fd736e452fb237d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">How the PIMPL is stored. <br /></td></tr>
<tr class="separator:a56f22739d8829d8fd736e452fb237d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae51363b5fe4dfd20262c4613fb65fa8" id="r_aae51363b5fe4dfd20262c4613fb65fa8"><td class="memItemLeft" align="right" valign="top"><a id="aae51363b5fe4dfd20262c4613fb65fa8" name="aae51363b5fe4dfd20262c4613fb65fa8"></a>
<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rtti_type</b> = std::type_index</td></tr>
<tr class="memdesc:aae51363b5fe4dfd20262c4613fb65fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type the Any class hierarchy uses for RTTI purposes. <br /></td></tr>
<tr class="separator:aae51363b5fe4dfd20262c4613fb65fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e564f4e195101efb54764ce0c0408c1" id="r_a2e564f4e195101efb54764ce0c0408c1"><td class="memItemLeft" align="right" valign="top"><a id="a2e564f4e195101efb54764ce0c0408c1" name="a2e564f4e195101efb54764ce0c0408c1"></a>
<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>python_value</b> = <a class="el" href="classpluginplay_1_1python_1_1PythonWrapper.html">python::PythonWrapper</a></td></tr>
<tr class="memdesc:a2e564f4e195101efb54764ce0c0408c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type we use for holding Python objects. <br /></td></tr>
<tr class="separator:a2e564f4e195101efb54764ce0c0408c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad317aca2661c5eece9057906d547687f" id="r_ad317aca2661c5eece9057906d547687f"><td class="memItemLeft" align="right" valign="top"><a id="ad317aca2661c5eece9057906d547687f" name="ad317aca2661c5eece9057906d547687f"></a>
<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>python_reference</b> = <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#a2e564f4e195101efb54764ce0c0408c1">python_value</a> &amp;</td></tr>
<tr class="memdesc:ad317aca2661c5eece9057906d547687f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A read/write reference to a Python object. <br /></td></tr>
<tr class="separator:ad317aca2661c5eece9057906d547687f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae706ac0e21782ad4fd7c073d92ca19ac" id="r_ae706ac0e21782ad4fd7c073d92ca19ac"><td class="memItemLeft" align="right" valign="top"><a id="ae706ac0e21782ad4fd7c073d92ca19ac" name="ae706ac0e21782ad4fd7c073d92ca19ac"></a>
<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>const_python_reference</b> = <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">const</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#a2e564f4e195101efb54764ce0c0408c1">python_value</a> &amp;</td></tr>
<tr class="memdesc:ae706ac0e21782ad4fd7c073d92ca19ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">A read-only reference to a Python object. <br /></td></tr>
<tr class="separator:ae706ac0e21782ad4fd7c073d92ca19ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc872743c82c558c558483a6bca2ac79" id="r_adc872743c82c558c558483a6bca2ac79"><td class="memItemLeft" align="right" valign="top"><a id="adc872743c82c558c558483a6bca2ac79" name="adc872743c82c558c558483a6bca2ac79"></a>
<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = boost::any</td></tr>
<tr class="memdesc:adc872743c82c558c558483a6bca2ac79"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to store the value. <br /></td></tr>
<tr class="separator:adc872743c82c558c558483a6bca2ac79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a090ff0fc141b2b791bc83086041301d8" id="r_a090ff0fc141b2b791bc83086041301d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#a56f22739d8829d8fd736e452fb237d2c">field_base_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#a090ff0fc141b2b791bc83086041301d8">clone</a> () <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">const</a></td></tr>
<tr class="memdesc:a090ff0fc141b2b791bc83086041301d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic copy.  <br /></td></tr>
<tr class="separator:a090ff0fc141b2b791bc83086041301d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411bd0df14f9c9cdb960dde3445dd44f" id="r_a411bd0df14f9c9cdb960dde3445dd44f"><td class="memItemLeft" align="right" valign="top"><a id="a411bd0df14f9c9cdb960dde3445dd44f" name="a411bd0df14f9c9cdb960dde3445dd44f"></a>
<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">virtual</a>&#160;</td><td class="memItemRight" valign="bottom"><b>~AnyFieldBase</b> () <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">noexcept</a>=<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">default</a></td></tr>
<tr class="memdesc:a411bd0df14f9c9cdb960dde3445dd44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard polymorphic dtor. <br /></td></tr>
<tr class="separator:a411bd0df14f9c9cdb960dde3445dd44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce659cb729672118ac1e8909d52d837" id="r_a9ce659cb729672118ac1e8909d52d837"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#aae51363b5fe4dfd20262c4613fb65fa8">rtti_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#a9ce659cb729672118ac1e8909d52d837">type</a> () <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">const</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">noexcept</a></td></tr>
<tr class="memdesc:a9ce659cb729672118ac1e8909d52d837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the RTTI for the wrapped object.  <br /></td></tr>
<tr class="separator:a9ce659cb729672118ac1e8909d52d837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d9645a687723fd5986d99b41b9e324" id="r_a93d9645a687723fd5986d99b41b9e324"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">typename</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">T</a> &gt; </td></tr>
<tr class="memitem:a93d9645a687723fd5986d99b41b9e324"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#a93d9645a687723fd5986d99b41b9e324">is_convertible</a> () <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">noexcept</a></td></tr>
<tr class="memdesc:a93d9645a687723fd5986d99b41b9e324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the wrapped value can be retrieved as type <code>T</code>.  <br /></td></tr>
<tr class="separator:a93d9645a687723fd5986d99b41b9e324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c20197d83feed9fae53371a1cdb7928" id="r_a0c20197d83feed9fae53371a1cdb7928"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">typename</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">T</a> &gt; </td></tr>
<tr class="memitem:a0c20197d83feed9fae53371a1cdb7928"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#a0c20197d83feed9fae53371a1cdb7928">is_convertible</a> () <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">const</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">noexcept</a></td></tr>
<tr class="memdesc:a0c20197d83feed9fae53371a1cdb7928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the wrapped value can be retrieved as type <code>T</code>.  <br /></td></tr>
<tr class="separator:a0c20197d83feed9fae53371a1cdb7928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac65d2f023c04adc1cfc137512b5a628" id="r_aac65d2f023c04adc1cfc137512b5a628"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#a2e564f4e195101efb54764ce0c0408c1">python_value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#aac65d2f023c04adc1cfc137512b5a628">as_python_wrapper</a> () <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">const</a></td></tr>
<tr class="memdesc:aac65d2f023c04adc1cfc137512b5a628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwraps the wrapped object into a PythonWrapper.  <br /></td></tr>
<tr class="separator:aac65d2f023c04adc1cfc137512b5a628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6c6eb8d5ef5464dc771f034732f2b8" id="r_aef6c6eb8d5ef5464dc771f034732f2b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#aef6c6eb8d5ef5464dc771f034732f2b8">storing_const_value</a> () <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">const</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">noexcept</a></td></tr>
<tr class="memdesc:aef6c6eb8d5ef5464dc771f034732f2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if *this is holding the value, but won't let the user modify it.  <br /></td></tr>
<tr class="separator:aef6c6eb8d5ef5464dc771f034732f2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc3f82fb072bbb94aa836e5662cf446" id="r_a1dc3f82fb072bbb94aa836e5662cf446"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#a1dc3f82fb072bbb94aa836e5662cf446">storing_const_reference</a> () <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">const</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">noexcept</a></td></tr>
<tr class="memdesc:a1dc3f82fb072bbb94aa836e5662cf446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to determine if *this is holding a read-only reference to a value.  <br /></td></tr>
<tr class="separator:a1dc3f82fb072bbb94aa836e5662cf446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16e0a2326295f379a0fb143cf721d28" id="r_ae16e0a2326295f379a0fb143cf721d28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#ae16e0a2326295f379a0fb143cf721d28">storing_python_object</a> () <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">const</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">noexcept</a></td></tr>
<tr class="memdesc:ae16e0a2326295f379a0fb143cf721d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to determine if *this holds a Python object.  <br /></td></tr>
<tr class="separator:ae16e0a2326295f379a0fb143cf721d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c5f95a6f3827149c939b1a53bee098" id="r_ac4c5f95a6f3827149c939b1a53bee098"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#ac4c5f95a6f3827149c939b1a53bee098">are_equal</a> (<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">const</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html">AnyFieldBase</a> &amp;<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">rhs</a>) <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">const</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">noexcept</a></td></tr>
<tr class="memdesc:ac4c5f95a6f3827149c939b1a53bee098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymophically compares two objects derived from <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html">AnyFieldBase</a>.  <br /></td></tr>
<tr class="separator:ac4c5f95a6f3827149c939b1a53bee098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f1857afbbbf939ec5225ac4c38f6b2" id="r_ab6f1857afbbbf939ec5225ac4c38f6b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#ab6f1857afbbbf939ec5225ac4c38f6b2">value_equal</a> (<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">const</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html">AnyFieldBase</a> &amp;<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">rhs</a>) <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">const</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">noexcept</a></td></tr>
<tr class="memdesc:ab6f1857afbbbf939ec5225ac4c38f6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the value wrapped by two <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> instances are equal.  <br /></td></tr>
<tr class="separator:ab6f1857afbbbf939ec5225ac4c38f6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeac32ad858a0903d8cd35068ffcbc1d" id="r_aaeac32ad858a0903d8cd35068ffcbc1d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#aaeac32ad858a0903d8cd35068ffcbc1d">print</a> (std::ostream &amp;<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">os</a>) <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">const</a></td></tr>
<tr class="memdesc:aaeac32ad858a0903d8cd35068ffcbc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a text representation of the wrapped object to <code>os</code>.  <br /></td></tr>
<tr class="separator:aaeac32ad858a0903d8cd35068ffcbc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb53efa6cb381fa7835442fd51cb9100" id="r_aeb53efa6cb381fa7835442fd51cb9100"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">typename</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">T</a> &gt; </td></tr>
<tr class="memitem:aeb53efa6cb381fa7835442fd51cb9100"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#aeb53efa6cb381fa7835442fd51cb9100">cast</a> ()</td></tr>
<tr class="memdesc:aeb53efa6cb381fa7835442fd51cb9100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the value as an instance of type T.  <br /></td></tr>
<tr class="separator:aeb53efa6cb381fa7835442fd51cb9100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1525f29537f1f787b8d55c2ce48034" id="r_a0f1525f29537f1f787b8d55c2ce48034"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">typename</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">T</a> &gt; </td></tr>
<tr class="memitem:a0f1525f29537f1f787b8d55c2ce48034"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#a0f1525f29537f1f787b8d55c2ce48034">cast</a> () <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">const</a></td></tr>
<tr class="memdesc:a0f1525f29537f1f787b8d55c2ce48034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the value as an instance of type T.  <br /></td></tr>
<tr class="separator:a0f1525f29537f1f787b8d55c2ce48034"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a665b839a142d9403bd05ad75cbb315f2" id="r_a665b839a142d9403bd05ad75cbb315f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#a665b839a142d9403bd05ad75cbb315f2">AnyFieldBase</a> (<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#adc872743c82c558c558483a6bca2ac79">value_type</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">da_any</a>)</td></tr>
<tr class="separator:a665b839a142d9403bd05ad75cbb315f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5a28c37bf5f83ebd42e0a8eb140c9c" id="r_a0c5a28c37bf5f83ebd42e0a8eb140c9c"><td class="memItemLeft" align="right" valign="top"><a id="a0c5a28c37bf5f83ebd42e0a8eb140c9c" name="a0c5a28c37bf5f83ebd42e0a8eb140c9c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AnyFieldBase</b> (<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">const</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html">AnyFieldBase</a> &amp;<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">other</a>)=<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">delete</a></td></tr>
<tr class="separator:a0c5a28c37bf5f83ebd42e0a8eb140c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a665b839a142d9403bd05ad75cbb315f2" name="a665b839a142d9403bd05ad75cbb315f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665b839a142d9403bd05ad75cbb315f2">&#9670;&#160;</a></span>AnyFieldBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pluginplay::any::detail_::AnyFieldBase::AnyFieldBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#adc872743c82c558c558483a6bca2ac79">value_type</a>&#160;</td>
          <td class="paramname"><em>da_any</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>AnyWrappers are always created via AnyResultWrapper/AnyInputWrapper </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac4c5f95a6f3827149c939b1a53bee098" name="ac4c5f95a6f3827149c939b1a53bee098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c5f95a6f3827149c939b1a53bee098">&#9670;&#160;</a></span>are_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">bool</a> pluginplay::any::detail_::AnyFieldBase::are_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">const</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html">AnyFieldBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polymophically compares two objects derived from <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html">AnyFieldBase</a>. </p>
<p>This function is actually implemented by symmetrically calling <code>are_equal_</code> (<em>i.e.</em> checking <code>this-&gt;are_equal_(rhs) &amp;&amp; rhs.are_equal_(*this)</code>). <code>are_equal_</code> is a virtual function which the derived class implements to check if:</p>
<ol type="1">
<li>The input instance can be downcast to the derived class, and</li>
<li>that the states in the derived classes are the same.</li>
</ol>
<p>By calling it symmetrically we guarantee that both this instance and <code>rhs</code> have the same most derived class. Of note for our purposes this guarantees that both this instance and <code>rhs</code> are both wrapping the same value in the same way (by value, by ref, by const val, etc.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance we are comparing to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the most derived type of this instance compares equal to the most derived type of <code>rhs</code>, and if the state of each type in this instance's hierarchy compares equal to the state of teh corresponding type in <code>rhs's</code> hierarchy.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac65d2f023c04adc1cfc137512b5a628" name="aac65d2f023c04adc1cfc137512b5a628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac65d2f023c04adc1cfc137512b5a628">&#9670;&#160;</a></span>as_python_wrapper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#a2e564f4e195101efb54764ce0c0408c1">python_value</a> pluginplay::any::detail_::AnyFieldBase::as_python_wrapper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unwraps the wrapped object into a PythonWrapper. </p>
<p>This method will wrap the wrapped object into a PythonWrapper, sight</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if PluginPlay was not compiled with Pybind11 support. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb53efa6cb381fa7835442fd51cb9100" name="aeb53efa6cb381fa7835442fd51cb9100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb53efa6cb381fa7835442fd51cb9100">&#9670;&#160;</a></span>cast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">typename</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">T</a> pluginplay::any::detail_::AnyFieldBase::cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the value as an instance of type T. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The exact type to retrieve the value as. <code>T</code> should include the desired cv-qualifiers and whether it is to be a reference or not.</td></tr>
  </table>
  </dd>
</dl>
<p>Based on how the ctors for the <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html">AnyFieldBase</a> class hierarchy work, each instance must always wrap a value (if an <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> does not wrap a value it simply holds a nullptr). This function can be used to retrieve the wrapped value as an object of type <code>T</code>, assuming the wrapped object can be converted to an object of type <code>T</code>. See the is_convertible method for details on what conversions are allowed.</p>
<p>This overload is selected when the <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html">AnyFieldBase</a> is mutable.</p>
<dl class="section return"><dt>Returns</dt><dd>The wrapped instance as instance of type <code>T</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the wrapped instance can not be retrieved as an instance of type <code>T</code> as determined by the is_convertible method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f1525f29537f1f787b8d55c2ce48034" name="a0f1525f29537f1f787b8d55c2ce48034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1525f29537f1f787b8d55c2ce48034">&#9670;&#160;</a></span>cast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">typename</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">T</a> pluginplay::any::detail_::AnyFieldBase::cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the value as an instance of type T. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The exact type to retrieve the value as. <code>T</code> should include the desired cv-qualifiers and whether it is to be a reference or not.</td></tr>
  </table>
  </dd>
</dl>
<p>Based on how the ctors for the <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html">AnyFieldBase</a> class hierarchy work, each instance must always wrap a value (if an <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> does not wrap a value it simply holds a nullptr). This function can be used to retrieve the wrapped value as an object of type <code>T</code>, assuming the wrapped object can be converted to an object of type <code>T</code>. See the is_convertible method for details on what conversions are allowed.</p>
<p>This overload is selected when the <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html">AnyFieldBase</a> is read-only</p>
<dl class="section return"><dt>Returns</dt><dd>The wrapped instance as instance of type <code>T</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the wrapped instance can not be retrieved as an instance of type <code>T</code> as determined by the is_convertible method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a090ff0fc141b2b791bc83086041301d8" name="a090ff0fc141b2b791bc83086041301d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090ff0fc141b2b791bc83086041301d8">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#a56f22739d8829d8fd736e452fb237d2c">field_base_pointer</a> pluginplay::any::detail_::AnyFieldBase::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polymorphic copy. </p>
<p>This method returns a pointer to a newly allocated <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html">AnyFieldBase</a> instance which contains a deep copy of this instance's state. The copied state is not only the state in the <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html">AnyFieldBase</a> class, but also the state in the derived class as well.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a newly allocated, polymorphic deep copy of this instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the new state. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c20197d83feed9fae53371a1cdb7928" name="a0c20197d83feed9fae53371a1cdb7928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c20197d83feed9fae53371a1cdb7928">&#9670;&#160;</a></span>is_convertible() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">typename</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">bool</a> pluginplay::any::detail_::AnyFieldBase::is_convertible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the wrapped value can be retrieved as type <code>T</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The fully qualified (cv-qualifications and/or reference) type you would like to get the wrapped value back as.</td></tr>
  </table>
  </dd>
</dl>
<p>This overload of <code>is_convertible</code> is invoked when the AnyInputBase is read-only. Since the AnyInputBase is read-only it will only allow you to retrieve the wrapped value in a manner that does not allow you to modify it. Namely this function will return true if you request to get the value back by value, const value, or read-only reference (and if the wrapped value is actually of type <code>std::decay_t&lt;T&gt;</code>).</p>
<dl class="section return"><dt>Returns</dt><dd>True if the wrapped instance can be returned as type <code>T</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93d9645a687723fd5986d99b41b9e324" name="a93d9645a687723fd5986d99b41b9e324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d9645a687723fd5986d99b41b9e324">&#9670;&#160;</a></span>is_convertible() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">typename</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">bool</a> pluginplay::any::detail_::AnyFieldBase::is_convertible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the wrapped value can be retrieved as type <code>T</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The fully qualified (cv-qualifications and/or reference) type you would like to get the wrapped value back as.</td></tr>
  </table>
  </dd>
</dl>
<p>This overload of <code>is_convertible</code> is invoked when the AnyInputBase is mutable. Whether we can convert the wrapped object to an object of type <code>T</code> depends on which of the following scenarios is true:</p>
<ol type="1">
<li>We wrap the object by mutable value</li>
<li>We hold the object in a read-only state (either by value or ref)</li>
</ol>
<p>For scenerio 1 we can return the object by value, const value, reference, or const reference. Scenario 2 is essentially the same as when AnyInputBase is itself read-only and we defer to the const overload of is_convertible for scenario 2.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the wrapped instance can be returned as type <code>T</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaeac32ad858a0903d8cd35068ffcbc1d" name="aaeac32ad858a0903d8cd35068ffcbc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeac32ad858a0903d8cd35068ffcbc1d">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; pluginplay::any::detail_::AnyFieldBase::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a text representation of the wrapped object to <code>os</code>. </p>
<p>This function is actually implemented by calling the virtual function print_. The derived class then uses basic template meta-programming to determine if the wrapped type is capable of being printed to a std::ostream. If it is, the wrapped type is inserted into the stream. If it is not, the type of the object and its address are inserted into the stream. Either way the modified stream is returned to support chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">os</td><td>The stream we are adding a text representation to. After this call <code>os</code> will contain a text representation of the wrapped object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code> After adding the text representation of the current object to it.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::ios_base::failure</td><td>if there is a problem writing to the stream. Weak throw guarantee (the wrapped object is still in the same state, but <code>os</code> is a potentially different state). </td></tr>
    <tr><td class="paramname">???</td><td>If calling <code>std::ostream::operator&lt;&lt;</code> on the wrapped type throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1dc3f82fb072bbb94aa836e5662cf446" name="a1dc3f82fb072bbb94aa836e5662cf446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc3f82fb072bbb94aa836e5662cf446">&#9670;&#160;</a></span>storing_const_reference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">bool</a> pluginplay::any::detail_::AnyFieldBase::storing_const_reference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to determine if *this is holding a read-only reference to a value. </p>
<p>To avoid copying objects, <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> instances are allowed to hold ready- only references to objects. The <code>storing_const_reference</code> method allows the caller to determine if *this wraps a read-only reference to the object.</p>
<dl class="section return"><dt>Returns</dt><dd>True if *this holds a read-only reference to an object and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef6c6eb8d5ef5464dc771f034732f2b8" name="aef6c6eb8d5ef5464dc771f034732f2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6c6eb8d5ef5464dc771f034732f2b8">&#9670;&#160;</a></span>storing_const_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">bool</a> pluginplay::any::detail_::AnyFieldBase::storing_const_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if *this is holding the value, but won't let the user modify it. </p>
<dl class="section return"><dt>Returns</dt><dd>True if *this if the type of the wrapped object is <code>const U</code> where <code>U</code> is an unqualified type and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae16e0a2326295f379a0fb143cf721d28" name="ae16e0a2326295f379a0fb143cf721d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16e0a2326295f379a0fb143cf721d28">&#9670;&#160;</a></span>storing_python_object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">bool</a> pluginplay::any::detail_::AnyFieldBase::storing_python_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to determine if *this holds a Python object. </p>
<p>If Pybind11 support is enabled <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> objects may hold Python objects. The storing_python_object method is used to determine if *this is holding a Python object (defined as the derived class's template type parameter being <code>python_value</code>).</p>
<dl class="section return"><dt>Returns</dt><dd>True if *this is holding a Python object and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ce659cb729672118ac1e8909d52d837" name="a9ce659cb729672118ac1e8909d52d837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce659cb729672118ac1e8909d52d837">&#9670;&#160;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html#aae51363b5fe4dfd20262c4613fb65fa8">rtti_type</a> pluginplay::any::detail_::AnyFieldBase::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the RTTI for the wrapped object. </p>
<p>This function is actually implemented by calling the virtual type_ function. The derived class (<a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html" title="Given knowledge of type T, implements AnyFieldBase.">AnyFieldWrapper</a>) is templated on the type of the wrapped object and implements type_ by simply returning the typeid of the template parameter.</p>
<p>Note the type that the derived class can wrap is fixed by the derived class's type, hence the type that this function can return can not change at runtime.</p>
<p>One should also note that typeid(T) == typeid(std::decay_t&lt;T&gt;) for all T. Meaning this function can not be used to determine how the value is stored in the derived class (storing_const_value and storing_const_reference can be though).</p>
<dl class="section return"><dt>Returns</dt><dd>The RTTI for the wrapped object.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6f1857afbbbf939ec5225ac4c38f6b2" name="ab6f1857afbbbf939ec5225ac4c38f6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f1857afbbbf939ec5225ac4c38f6b2">&#9670;&#160;</a></span>value_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">bool</a> pluginplay::any::detail_::AnyFieldBase::value_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldWrapper.html">const</a> <a class="el" href="classpluginplay_1_1any_1_1detail___1_1AnyFieldBase.html">AnyFieldBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the value wrapped by two <a class="el" href="classpluginplay_1_1any_1_1AnyField.html" title="Wraps either an input or a result to a module.">AnyField</a> instances are equal. </p>
<p>The difference between this and <code>are_equal</code> is say we have an AnyFieldWrapper&lt;T&gt; and an AnyFieldWrapper&lt;T&amp;&gt; (T being an unqualified type). <code>are_equal</code> will always return false because the derived classes of the hierarchy are different types. <code>value_equal</code>, however, will call <code>T::operator==</code> on the wrapped values to determine if they are equal.</p>
<p>Conceptually this method is sort of a non-polymorphic equality operator in the sense that it doesn't take into account the state of the derived class (in so far that the value is stored in this class and the type of the value is stored in the derived class). Rigorously there is no way for us to compare the values without going into the derived class so this comparison does have some polymorphic aspects to it. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/pluginplay/any/detail_/<a class="el" href="any__field__base_8hpp_source.html">any_field_base.hpp</a></li>
<li>include/pluginplay/any/detail_/<a class="el" href="any__field__base_8ipp_source.html">any_field_base.ipp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
