<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>pluginplay: pluginplay::SubmoduleRequest Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">pluginplay
   &#160;<span id="projectnumber">1.0.45</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pluginplay</b></li><li class="navelem"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpluginplay_1_1SubmoduleRequest-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pluginplay::SubmoduleRequest Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class that wraps a module's request for a particular submodule.  
 <a href="classpluginplay_1_1SubmoduleRequest.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="submodule__request_8hpp_source.html">submodule_request.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a372e835f584280aa70cb34553d17f97a"><td class="memItemLeft" align="right" valign="top"><a id="a372e835f584280aa70cb34553d17f97a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a372e835f584280aa70cb34553d17f97a">module_ptr</a> = std::shared_ptr&lt; <a class="el" href="classpluginplay_1_1Module.html">Module</a> &gt;</td></tr>
<tr class="memdesc:a372e835f584280aa70cb34553d17f97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a shared pointer to a module, how the submodule is stored. <br /></td></tr>
<tr class="separator:a372e835f584280aa70cb34553d17f97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f8e0cac07df505765a6bc4dbdd4680"><td class="memItemLeft" align="right" valign="top"><a id="ad1f8e0cac07df505765a6bc4dbdd4680"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#ad1f8e0cac07df505765a6bc4dbdd4680">uuid_type</a> = typename <a class="el" href="classpluginplay_1_1Module.html#a3fdd4c01406da7ebddbf31259b108478">Module::uuid_type</a></td></tr>
<tr class="memdesc:ad1f8e0cac07df505765a6bc4dbdd4680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to hold the wrapped <a class="el" href="classpluginplay_1_1Module.html" title="The public API of all modules.">Module</a>'s UUID. <br /></td></tr>
<tr class="separator:ad1f8e0cac07df505765a6bc4dbdd4680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772757c21c35cf30fcdef7f98b7eff96"><td class="memItemLeft" align="right" valign="top"><a id="a772757c21c35cf30fcdef7f98b7eff96"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a772757c21c35cf30fcdef7f98b7eff96">submod_uuid_map</a> = typename <a class="el" href="classpluginplay_1_1Module.html#a92bee556e6935e51eec08b7d0dbaacdd">Module::submod_uuid_map</a></td></tr>
<tr class="memdesc:a772757c21c35cf30fcdef7f98b7eff96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of map, mapping submodule keys to UUIDs. <br /></td></tr>
<tr class="separator:a772757c21c35cf30fcdef7f98b7eff96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f992c56a0ffa57cacead2bde0046921"><td class="memItemLeft" align="right" valign="top"><a id="a7f992c56a0ffa57cacead2bde0046921"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a7f992c56a0ffa57cacead2bde0046921">rtti_type</a> = <a class="el" href="namespacepluginplay_1_1type.html#a8dd6f4c8509d26017a93644edc3574e0">type::rtti</a></td></tr>
<tr class="memdesc:a7f992c56a0ffa57cacead2bde0046921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for RTTI. <br /></td></tr>
<tr class="separator:a7f992c56a0ffa57cacead2bde0046921"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad52fbb6af1c785f76a4b5f1a2581c73a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#ad52fbb6af1c785f76a4b5f1a2581c73a">SubmoduleRequest</a> ()</td></tr>
<tr class="memdesc:ad52fbb6af1c785f76a4b5f1a2581c73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an empty request.  <a href="classpluginplay_1_1SubmoduleRequest.html#ad52fbb6af1c785f76a4b5f1a2581c73a">More...</a><br /></td></tr>
<tr class="separator:ad52fbb6af1c785f76a4b5f1a2581c73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0132572477a54746e6b8d643654dfc2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a0132572477a54746e6b8d643654dfc2f">SubmoduleRequest</a> (const <a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;rhs)</td></tr>
<tr class="memdesc:a0132572477a54746e6b8d643654dfc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current request's state to a deep copy of <code>rhs</code>.  <a href="classpluginplay_1_1SubmoduleRequest.html#a0132572477a54746e6b8d643654dfc2f">More...</a><br /></td></tr>
<tr class="separator:a0132572477a54746e6b8d643654dfc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0a0b770a99df5024044b442965c6d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a1a0a0b770a99df5024044b442965c6d2">operator=</a> (const <a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;rhs)</td></tr>
<tr class="memdesc:a1a0a0b770a99df5024044b442965c6d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current request's state to a deep copy of <code>rhs</code>.  <a href="classpluginplay_1_1SubmoduleRequest.html#a1a0a0b770a99df5024044b442965c6d2">More...</a><br /></td></tr>
<tr class="separator:a1a0a0b770a99df5024044b442965c6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016ab98ba5a584bd59f03afc05c73d0e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a016ab98ba5a584bd59f03afc05c73d0e">SubmoduleRequest</a> (<a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:a016ab98ba5a584bd59f03afc05c73d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of another instance's state.  <a href="classpluginplay_1_1SubmoduleRequest.html#a016ab98ba5a584bd59f03afc05c73d0e">More...</a><br /></td></tr>
<tr class="separator:a016ab98ba5a584bd59f03afc05c73d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcb89779b9abf184095bd84d1481447"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#aebcb89779b9abf184095bd84d1481447">operator=</a> (<a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:aebcb89779b9abf184095bd84d1481447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of another instance's state.  <a href="classpluginplay_1_1SubmoduleRequest.html#aebcb89779b9abf184095bd84d1481447">More...</a><br /></td></tr>
<tr class="separator:aebcb89779b9abf184095bd84d1481447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcf10c693cce09fa8ab4d67abb8c5ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#abbcf10c693cce09fa8ab4d67abb8c5ec">~SubmoduleRequest</a> () noexcept</td></tr>
<tr class="memdesc:abbcf10c693cce09fa8ab4d67abb8c5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard destructor.  <a href="classpluginplay_1_1SubmoduleRequest.html#abbcf10c693cce09fa8ab4d67abb8c5ec">More...</a><br /></td></tr>
<tr class="separator:abbcf10c693cce09fa8ab4d67abb8c5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a639cab2bfc429c171ba6c0d93af8d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a4a639cab2bfc429c171ba6c0d93af8d5">has_type</a> () const noexcept</td></tr>
<tr class="memdesc:a4a639cab2bfc429c171ba6c0d93af8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the property type the submodule needs to satisfy been set?  <a href="classpluginplay_1_1SubmoduleRequest.html#a4a639cab2bfc429c171ba6c0d93af8d5">More...</a><br /></td></tr>
<tr class="separator:a4a639cab2bfc429c171ba6c0d93af8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58417e7ccf2d7253248a9439b885481"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#ab58417e7ccf2d7253248a9439b885481">has_module</a> () const noexcept</td></tr>
<tr class="memdesc:ab58417e7ccf2d7253248a9439b885481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has this request been fulfilled?  <a href="classpluginplay_1_1SubmoduleRequest.html#ab58417e7ccf2d7253248a9439b885481">More...</a><br /></td></tr>
<tr class="separator:ab58417e7ccf2d7253248a9439b885481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d844d94161d20ead8ab01f40ea28640"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a3d844d94161d20ead8ab01f40ea28640">has_description</a> () const noexcept</td></tr>
<tr class="memdesc:a3d844d94161d20ead8ab01f40ea28640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the description been set?  <a href="classpluginplay_1_1SubmoduleRequest.html#a3d844d94161d20ead8ab01f40ea28640">More...</a><br /></td></tr>
<tr class="separator:a3d844d94161d20ead8ab01f40ea28640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98216d93d9f538b0d0539f03481095a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a98216d93d9f538b0d0539f03481095a0">has_name</a> () const</td></tr>
<tr class="memdesc:a98216d93d9f538b0d0539f03481095a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this module have a name?  <a href="classpluginplay_1_1SubmoduleRequest.html#a98216d93d9f538b0d0539f03481095a0">More...</a><br /></td></tr>
<tr class="separator:a98216d93d9f538b0d0539f03481095a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc23220d3a32af1bdb9151db7bf143eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#adc23220d3a32af1bdb9151db7bf143eb">ready</a> () const noexcept</td></tr>
<tr class="memdesc:adc23220d3a32af1bdb9151db7bf143eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the wrapped submodule can be used.  <a href="classpluginplay_1_1SubmoduleRequest.html#adc23220d3a32af1bdb9151db7bf143eb">More...</a><br /></td></tr>
<tr class="separator:adc23220d3a32af1bdb9151db7bf143eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06b2ea8c51365961c1549c2e7108604"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab06b2ea8c51365961c1549c2e7108604"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#ab06b2ea8c51365961c1549c2e7108604">set_type</a> ()</td></tr>
<tr class="memdesc:ab06b2ea8c51365961c1549c2e7108604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the property type the submodule must satisfy.  <a href="classpluginplay_1_1SubmoduleRequest.html#ab06b2ea8c51365961c1549c2e7108604">More...</a><br /></td></tr>
<tr class="separator:ab06b2ea8c51365961c1549c2e7108604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71aa44b7ead67342a77e35d205b6f121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a71aa44b7ead67342a77e35d205b6f121">set_type</a> (<a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a7f992c56a0ffa57cacead2bde0046921">rtti_type</a> <a class="el" href="classpluginplay_1_1SubmoduleRequest.html#aad441aa19b99ddd1e9ce5cbd57dec393">type</a>, <a class="el" href="namespacepluginplay_1_1type.html#a5b3cceb4e9a4b73288a4e173b92ab50d">type::input_map</a> inputs)</td></tr>
<tr class="memdesc:a71aa44b7ead67342a77e35d205b6f121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses RTTI to set the type of *this.  <a href="classpluginplay_1_1SubmoduleRequest.html#a71aa44b7ead67342a77e35d205b6f121">More...</a><br /></td></tr>
<tr class="separator:a71aa44b7ead67342a77e35d205b6f121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f142d9b60b9aeb27aa6eb393faac35"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a47f142d9b60b9aeb27aa6eb393faac35"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a47f142d9b60b9aeb27aa6eb393faac35">satisfies_property_type</a> ()</td></tr>
<tr class="memdesc:a47f142d9b60b9aeb27aa6eb393faac35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the submodule satisfies a specific property type.  <a href="classpluginplay_1_1SubmoduleRequest.html#a47f142d9b60b9aeb27aa6eb393faac35">More...</a><br /></td></tr>
<tr class="separator:a47f142d9b60b9aeb27aa6eb393faac35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7d166d875149255ebe592557021313"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a8a7d166d875149255ebe592557021313">satisfies_property_type</a> (<a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a7f992c56a0ffa57cacead2bde0046921">rtti_type</a> <a class="el" href="classpluginplay_1_1SubmoduleRequest.html#aad441aa19b99ddd1e9ce5cbd57dec393">type</a>)</td></tr>
<tr class="memdesc:a8a7d166d875149255ebe592557021313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check by RTTI if the submodule satisfies a specific property type.  <a href="classpluginplay_1_1SubmoduleRequest.html#a8a7d166d875149255ebe592557021313">More...</a><br /></td></tr>
<tr class="separator:a8a7d166d875149255ebe592557021313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935fd0118e827ca0cba99324fe5d0419"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a935fd0118e827ca0cba99324fe5d0419">change</a> (<a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a372e835f584280aa70cb34553d17f97a">module_ptr</a> new_module)</td></tr>
<tr class="memdesc:a935fd0118e827ca0cba99324fe5d0419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module that is to be used to satisfy the request.  <a href="classpluginplay_1_1SubmoduleRequest.html#a935fd0118e827ca0cba99324fe5d0419">More...</a><br /></td></tr>
<tr class="separator:a935fd0118e827ca0cba99324fe5d0419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c877a265524500aa5dcdba2b78078f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#ac9c877a265524500aa5dcdba2b78078f">change</a> (<a class="el" href="classpluginplay_1_1Module.html">Module</a> new_module)</td></tr>
<tr class="memdesc:ac9c877a265524500aa5dcdba2b78078f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fulfills the request with <code>new_module</code>.  <a href="classpluginplay_1_1SubmoduleRequest.html#ac9c877a265524500aa5dcdba2b78078f">More...</a><br /></td></tr>
<tr class="separator:ac9c877a265524500aa5dcdba2b78078f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c28c9c75a3cca4eadea1d6654e1856"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#af7c28c9c75a3cca4eadea1d6654e1856">change</a> (const <a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;new_module)</td></tr>
<tr class="memdesc:af7c28c9c75a3cca4eadea1d6654e1856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fulfills the request with the module used to satisfy another request.  <a href="classpluginplay_1_1SubmoduleRequest.html#af7c28c9c75a3cca4eadea1d6654e1856">More...</a><br /></td></tr>
<tr class="separator:af7c28c9c75a3cca4eadea1d6654e1856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcb8f922e95c2320ef585b01585b453"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a6bcb8f922e95c2320ef585b01585b453">set_description</a> (<a class="el" href="namespacepluginplay_1_1type.html#a6ac6703e3c574d225a21b4abec89e29a">type::description</a> desc) noexcept</td></tr>
<tr class="memdesc:a6bcb8f922e95c2320ef585b01585b453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the human-readable description for the this request.  <a href="classpluginplay_1_1SubmoduleRequest.html#a6bcb8f922e95c2320ef585b01585b453">More...</a><br /></td></tr>
<tr class="separator:a6bcb8f922e95c2320ef585b01585b453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad441aa19b99ddd1e9ce5cbd57dec393"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepluginplay_1_1type.html#a8dd6f4c8509d26017a93644edc3574e0">type::rtti</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#aad441aa19b99ddd1e9ce5cbd57dec393">type</a> () const</td></tr>
<tr class="memdesc:aad441aa19b99ddd1e9ce5cbd57dec393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the RTTI of the property type this submodule must satisfy.  <a href="classpluginplay_1_1SubmoduleRequest.html#aad441aa19b99ddd1e9ce5cbd57dec393">More...</a><br /></td></tr>
<tr class="separator:aad441aa19b99ddd1e9ce5cbd57dec393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3379b093eacb1ec5e999e2250049a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a772757c21c35cf30fcdef7f98b7eff96">submod_uuid_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#aad3379b093eacb1ec5e999e2250049a3">submod_uuids</a> () const</td></tr>
<tr class="memdesc:aad3379b093eacb1ec5e999e2250049a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a convenience function for calling submod_uuids on the wrapped module.  <a href="classpluginplay_1_1SubmoduleRequest.html#aad3379b093eacb1ec5e999e2250049a3">More...</a><br /></td></tr>
<tr class="separator:aad3379b093eacb1ec5e999e2250049a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03932df3a61dd078ba304f7621571008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#ad1f8e0cac07df505765a6bc4dbdd4680">uuid_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a03932df3a61dd078ba304f7621571008">uuid</a> () const</td></tr>
<tr class="memdesc:a03932df3a61dd078ba304f7621571008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the UUID of the wrapped module.  <a href="classpluginplay_1_1SubmoduleRequest.html#a03932df3a61dd078ba304f7621571008">More...</a><br /></td></tr>
<tr class="separator:a03932df3a61dd078ba304f7621571008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7e1c8be2f4595773a20fa37f0e8a6d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpluginplay_1_1Module.html">Module</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#aaa7e1c8be2f4595773a20fa37f0e8a6d">value</a> () const</td></tr>
<tr class="memdesc:aaa7e1c8be2f4595773a20fa37f0e8a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the module used to satisfy this request in a read-only state.  <a href="classpluginplay_1_1SubmoduleRequest.html#aaa7e1c8be2f4595773a20fa37f0e8a6d">More...</a><br /></td></tr>
<tr class="separator:aaa7e1c8be2f4595773a20fa37f0e8a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ad2fe8526464addc490e9b31b37b12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpluginplay_1_1Module.html">Module</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a07ad2fe8526464addc490e9b31b37b12">value</a> ()</td></tr>
<tr class="memdesc:a07ad2fe8526464addc490e9b31b37b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the module used to satisfy this request in a read/write state.  <a href="classpluginplay_1_1SubmoduleRequest.html#a07ad2fe8526464addc490e9b31b37b12">More...</a><br /></td></tr>
<tr class="separator:a07ad2fe8526464addc490e9b31b37b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a5d234aa96de0ec5b6eda3c0b3aec2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacepluginplay_1_1type.html#a6ac6703e3c574d225a21b4abec89e29a">type::description</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#aa1a5d234aa96de0ec5b6eda3c0b3aec2">description</a> () const</td></tr>
<tr class="memdesc:aa1a5d234aa96de0ec5b6eda3c0b3aec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to retrieve the description of this request.  <a href="classpluginplay_1_1SubmoduleRequest.html#aa1a5d234aa96de0ec5b6eda3c0b3aec2">More...</a><br /></td></tr>
<tr class="separator:aa1a5d234aa96de0ec5b6eda3c0b3aec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7213c8d21873a2f9303cc54a5fb76dc2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a7213c8d21873a2f9303cc54a5fb76dc2">get_name</a> () const</td></tr>
<tr class="memdesc:a7213c8d21873a2f9303cc54a5fb76dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the module, if set.  <a href="classpluginplay_1_1SubmoduleRequest.html#a7213c8d21873a2f9303cc54a5fb76dc2">More...</a><br /></td></tr>
<tr class="separator:a7213c8d21873a2f9303cc54a5fb76dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0aa923ae6d78e3afa4b7687cd52d72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a5c0aa923ae6d78e3afa4b7687cd52d72">lock</a> ()</td></tr>
<tr class="memdesc:a5c0aa923ae6d78e3afa4b7687cd52d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the submodule.  <a href="classpluginplay_1_1SubmoduleRequest.html#a5c0aa923ae6d78e3afa4b7687cd52d72">More...</a><br /></td></tr>
<tr class="separator:a5c0aa923ae6d78e3afa4b7687cd52d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc7a34eccd38d95f883c9979af3bea3"><td class="memTemplParams" colspan="2">template&lt;typename property_type , typename... Args&gt; </td></tr>
<tr class="memitem:a5dc7a34eccd38d95f883c9979af3bea3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a5dc7a34eccd38d95f883c9979af3bea3">run_as</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a5dc7a34eccd38d95f883c9979af3bea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the submodule with the given arguments.  <a href="classpluginplay_1_1SubmoduleRequest.html#a5dc7a34eccd38d95f883c9979af3bea3">More...</a><br /></td></tr>
<tr class="separator:a5dc7a34eccd38d95f883c9979af3bea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428934eff1eb62b0e56cc28c8e73e167"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a428934eff1eb62b0e56cc28c8e73e167">operator==</a> (const <a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a428934eff1eb62b0e56cc28c8e73e167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classpluginplay_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule.">SubmoduleRequest</a> instances for equality.  <a href="classpluginplay_1_1SubmoduleRequest.html#a428934eff1eb62b0e56cc28c8e73e167">More...</a><br /></td></tr>
<tr class="separator:a428934eff1eb62b0e56cc28c8e73e167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a03d8e286b64a37a91bf8d4fdc2aee9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a7a03d8e286b64a37a91bf8d4fdc2aee9">operator!=</a> (const <a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a7a03d8e286b64a37a91bf8d4fdc2aee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dertermines if two <a class="el" href="classpluginplay_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule.">SubmoduleRequest</a> instances are different.  <a href="classpluginplay_1_1SubmoduleRequest.html#a7a03d8e286b64a37a91bf8d4fdc2aee9">More...</a><br /></td></tr>
<tr class="separator:a7a03d8e286b64a37a91bf8d4fdc2aee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class that wraps a module's request for a particular submodule. </p>
<p>When a module needs to use a submodule as part of its <code>run</code> function, the module creates an instance of this class. For the most part, a submodule request comes down to one thing, the property type that the submodule must satisfy. The <a class="el" href="classpluginplay_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule.">SubmoduleRequest</a> class stores the requested property type as well as some other metadata such as the description.</p>
<p>Note that there is a cyclic dependency between the <a class="el" href="classpluginplay_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule.">SubmoduleRequest</a> class and the <a class="el" href="classpluginplay_1_1Module.html" title="The public API of all modules.">Module</a> class, which results from the fact that a <a class="el" href="classpluginplay_1_1Module.html" title="The public API of all modules.">Module</a> holds a list of submodule requests and that each submodule request holds the module that is being used to satisfy the request. In practice this dependency is trivially handled because both classes only need forward declarations of the other for their respective declarations. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad52fbb6af1c785f76a4b5f1a2581c73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52fbb6af1c785f76a4b5f1a2581c73a">&#9670;&nbsp;</a></span>SubmoduleRequest() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pluginplay::SubmoduleRequest::SubmoduleRequest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes an empty request. </p>
<p>The request resulting from this call will have no description, no type, and no module.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to allocate the PIMPL. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0132572477a54746e6b8d643654dfc2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0132572477a54746e6b8d643654dfc2f">&#9670;&nbsp;</a></span>SubmoduleRequest() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pluginplay::SubmoduleRequest::SubmoduleRequest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current request's state to a deep copy of <code>rhs</code>. </p>
<p>This funciton will make a deep copy of another <a class="el" href="classpluginplay_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule.">SubmoduleRequest</a>'s state. This includes any bound module, if it exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance's state to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory for the copy. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a016ab98ba5a584bd59f03afc05c73d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016ab98ba5a584bd59f03afc05c73d0e">&#9670;&nbsp;</a></span>SubmoduleRequest() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pluginplay::SubmoduleRequest::SubmoduleRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership of another instance's state. </p>
<p>This ctor will make the current instance own <code>rhs's</code> state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance whose state will be taken. After this operation <code>rhs</code> is in a valid, but otherwise undefined state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbcf10c693cce09fa8ab4d67abb8c5ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcf10c693cce09fa8ab4d67abb8c5ec">&#9670;&nbsp;</a></span>~SubmoduleRequest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pluginplay::SubmoduleRequest::~SubmoduleRequest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard destructor. </p>
<p>After calling the dtor all references to metadata are invalid and the reference count of the wrapped module is decreased by one. Hence references to the module remain valid after the call to the dtor, until the reference count goes to zero.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af7c28c9c75a3cca4eadea1d6654e1856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c28c9c75a3cca4eadea1d6654e1856">&#9670;&nbsp;</a></span>change() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::SubmoduleRequest::change </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&#160;</td>
          <td class="paramname"><em>new_module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fulfills the request with the module used to satisfy another request. </p>
<p>This method fulfills *this with the same module used to satisfy request <code>new_module</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_module</td><td>The request providing the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_optional_access</td><td>if the property type has not been set yet. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if <code>new_module</code> is not of the correct property type. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9c877a265524500aa5dcdba2b78078f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c877a265524500aa5dcdba2b78078f">&#9670;&nbsp;</a></span>change() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::SubmoduleRequest::change </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpluginplay_1_1Module.html">Module</a>&#160;</td>
          <td class="paramname"><em>new_module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fulfills the request with <code>new_module</code>. </p>
<p>This method is a convenience method for working with <a class="el" href="classpluginplay_1_1Module.html" title="The public API of all modules.">Module</a> objects instead of pointers. It simply wraps <code>new_module</code> in a shared_ptr and dispatches to the shared_ptr overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_module</td><td>The module which should be used to satisfy this request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_optional_access</td><td>if the property type has not been set yet. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if <code>new_module</code> is not of the correct property type. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a935fd0118e827ca0cba99324fe5d0419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935fd0118e827ca0cba99324fe5d0419">&#9670;&nbsp;</a></span>change() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::SubmoduleRequest::change </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a372e835f584280aa70cb34553d17f97a">module_ptr</a>&#160;</td>
          <td class="paramname"><em>new_module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the module that is to be used to satisfy the request. </p>
<p>This function is designed to be called by the <a class="el" href="classpluginplay_1_1ModuleManager.html" title="Class responsible for holding and managing modules.">ModuleManager</a> via the <a class="el" href="classpluginplay_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule.">SubmoduleRequest</a> class in order to fulfill the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to the module to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>ptr</code> is null. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_optional_access</td><td>if the property type has not been set yet. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if <code>ptr</code> is not of the correct property type. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1a5d234aa96de0ec5b6eda3c0b3aec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a5d234aa96de0ec5b6eda3c0b3aec2">&#9670;&nbsp;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacepluginplay_1_1type.html#a6ac6703e3c574d225a21b4abec89e29a">type::description</a> &amp; pluginplay::SubmoduleRequest::description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to retrieve the description of this request. </p>
<p>Developers are encouraged to set the description of how a submodule will be used. If they set this description it can be retrieved via this function.</p>
<dl class="section return"><dt>Returns</dt><dd>The human-readable description of how this submodule will be used</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_optional_access</td><td>if the description has not been set yet. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7213c8d21873a2f9303cc54a5fb76dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7213c8d21873a2f9303cc54a5fb76dc2">&#9670;&nbsp;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacepluginplay_1_1type.html#ab8a1dcc0b6da631bd76087ca325a9359">type::key</a> &amp; pluginplay::SubmoduleRequest::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the module, if set. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of the module.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_optional_access</td><td>if this module does not have an name set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d844d94161d20ead8ab01f40ea28640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d844d94161d20ead8ab01f40ea28640">&#9670;&nbsp;</a></span>has_description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pluginplay::SubmoduleRequest::has_description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has the description been set? </p>
<p>Developers are encouraged to explain how a submodule will be used. This prose is the description of the <a class="el" href="classpluginplay_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule.">SubmoduleRequest</a> and is used for documentation and help purposes only. This function checks if the description has been set.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the description has been set and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab58417e7ccf2d7253248a9439b885481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58417e7ccf2d7253248a9439b885481">&#9670;&nbsp;</a></span>has_module()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pluginplay::SubmoduleRequest::has_module </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has this request been fulfilled? </p>
<p>This function checks to see if a submodule has been assigned to this request. Use set_module to actually fulfill the request.</p>
<dl class="section return"><dt>Returns</dt><dd>True if this request is satisfied and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98216d93d9f538b0d0539f03481095a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98216d93d9f538b0d0539f03481095a0">&#9670;&nbsp;</a></span>has_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pluginplay::SubmoduleRequest::has_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this module have a name? </p>
<p>This function is used to determine if the module has a name set.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the name has been set and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a639cab2bfc429c171ba6c0d93af8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a639cab2bfc429c171ba6c0d93af8d5">&#9670;&nbsp;</a></span>has_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pluginplay::SubmoduleRequest::has_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has the property type the submodule needs to satisfy been set? </p>
<p>This request is for a submodule that will compute a property for the parent module. This function is used to determine if the property type that the submodule must satisfy has been set.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the property type has been set and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c0aa923ae6d78e3afa4b7687cd52d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0aa923ae6d78e3afa4b7687cd52d72">&#9670;&nbsp;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::SubmoduleRequest::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks the submodule. </p>
<p>A locked module can no longer have its inputs and submodules modified. Locking a module helps avoid data races and problems with memoization that can occur if the inputs/submodules changed. This function locks the submodule. Since it would not be possible to ready a locked submodule (recall the property type is known and set) this function will throw if one attempts to lock an unready module.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the submodule is not ready. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a03d8e286b64a37a91bf8d4fdc2aee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a03d8e286b64a37a91bf8d4fdc2aee9">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pluginplay::SubmoduleRequest::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dertermines if two <a class="el" href="classpluginplay_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule.">SubmoduleRequest</a> instances are different. </p>
<p>Two <a class="el" href="classpluginplay_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule.">SubmoduleRequest</a> instances are equivalent if they both:</p><ul>
<li>request the same property type,</li>
<li>have the same description, and</li>
<li>are not satisfied or are both satisfied with the same module</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The request to compare against</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the this instances are the same and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the comparison between the two modules throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a0a0b770a99df5024044b442965c6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0a0b770a99df5024044b442965c6d2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp; pluginplay::SubmoduleRequest::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current request's state to a deep copy of <code>rhs</code>. </p>
<p>This function will overwrite the current instance's state with a deep copy of another <a class="el" href="classpluginplay_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule.">SubmoduleRequest</a>'s state. This includes any bound module, if it exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance's state to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance containing a deep copy of <code>rhs's</code> state.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory for the copy. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebcb89779b9abf184095bd84d1481447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcb89779b9abf184095bd84d1481447">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp; pluginplay::SubmoduleRequest::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership of another instance's state. </p>
<p>This function will overwrite the current instance's state with <code>rhs's</code> state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance whose state will be taken. After this operation <code>rhs</code> is in a valid, but otherwise undefined state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance with <code>rhs's</code> state.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a428934eff1eb62b0e56cc28c8e73e167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428934eff1eb62b0e56cc28c8e73e167">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pluginplay::SubmoduleRequest::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classpluginplay_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule.">SubmoduleRequest</a> instances for equality. </p>
<p>Two <a class="el" href="classpluginplay_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule.">SubmoduleRequest</a> instances are equivalent if they both:</p><ul>
<li>request the same property type,</li>
<li>have the same description, and</li>
<li>are not satisfied or are both satisfied with the same module</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The request to compare against</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the this instance is the same as <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the comparison between the two modules throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc23220d3a32af1bdb9151db7bf143eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc23220d3a32af1bdb9151db7bf143eb">&#9670;&nbsp;</a></span>ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pluginplay::SubmoduleRequest::ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the wrapped submodule can be used. </p>
<p>A submodule can be used if there is actually a submodule wrapped in the request and if that submodule reports that it is ready for use (the criteria for it being ready for use are identical to the <a class="el" href="classpluginplay_1_1Module.html" title="The public API of all modules.">Module</a> class).</p>
<dl class="section return"><dt>Returns</dt><dd>True if the current request contains a submodule that is ready for use and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dc7a34eccd38d95f883c9979af3bea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc7a34eccd38d95f883c9979af3bea3">&#9670;&nbsp;</a></span>run_as()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename property_type , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pluginplay::SubmoduleRequest::run_as </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the submodule with the given arguments. </p>
<p>This function is a convenience function for running the wrapped submodule as a particular property type. It is semantically the same as calling:</p>
<div class="fragment"><div class="line">this-&gt;<a class="code" href="classpluginplay_1_1SubmoduleRequest.html#aaa7e1c8be2f4595773a20fa37f0e8a6d">value</a>().<a class="code" href="classpluginplay_1_1Module.html#a200b448a122dbe825c75bcbce82c64a7">run_as</a>&lt;T&gt;(args...);</div>
<div class="ttc" id="aclasspluginplay_1_1Module_html_a200b448a122dbe825c75bcbce82c64a7"><div class="ttname"><a href="classpluginplay_1_1Module.html#a200b448a122dbe825c75bcbce82c64a7">pluginplay::Module::run_as</a></div><div class="ttdeci">auto run_as(Args &amp;&amp;... args)</div><div class="ttdoc">The primary API for running the encapsulated code.</div><div class="ttdef"><b>Definition:</b> module_class.hpp:764</div></div>
<div class="ttc" id="aclasspluginplay_1_1SubmoduleRequest_html_aaa7e1c8be2f4595773a20fa37f0e8a6d"><div class="ttname"><a href="classpluginplay_1_1SubmoduleRequest.html#aaa7e1c8be2f4595773a20fa37f0e8a6d">pluginplay::SubmoduleRequest::value</a></div><div class="ttdeci">const Module &amp; value() const</div><div class="ttdoc">Provides the module used to satisfy this request in a read-only state.</div><div class="ttdef"><b>Definition:</b> submodule_request.cpp:87</div></div>
</div><!-- fragment --><p>aside from the fact that it also asserts that the submodule is being run as the correct property type. Expert users can access the wrapped module via the <code>value</code> member and perform more advanced runs that way.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">property_type</td><td>The class defining the property type that the submodule should be run as. </td></tr>
    <tr><td class="paramname">Args</td><td>The types of the arguments to the property type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The values for the arguments to forward to the submodule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whatever the property type returns</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_optional_access</td><td>if the type has not been set yet. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the submodule is being run as a property type other than the one it should be. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the submodule has not been set yet. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47f142d9b60b9aeb27aa6eb393faac35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f142d9b60b9aeb27aa6eb393faac35">&#9670;&nbsp;</a></span>satisfies_property_type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pluginplay::SubmoduleRequest::satisfies_property_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the submodule satisfies a specific property type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The property type that is being checked</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if a property type has not been set. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a7d166d875149255ebe592557021313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7d166d875149255ebe592557021313">&#9670;&nbsp;</a></span>satisfies_property_type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pluginplay::SubmoduleRequest::satisfies_property_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a7f992c56a0ffa57cacead2bde0046921">rtti_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check by RTTI if the submodule satisfies a specific property type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>RTTI of the property type that is being checked</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if a property type has not been set. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bcb8f922e95c2320ef585b01585b453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bcb8f922e95c2320ef585b01585b453">&#9670;&nbsp;</a></span>set_description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp; pluginplay::SubmoduleRequest::set_description </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepluginplay_1_1type.html#a6ac6703e3c574d225a21b4abec89e29a">type::description</a>&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the human-readable description for the this request. </p>
<p>Developers are encouraged to provide descriptions for how a submodule will be used. This description is set by calling this function. If the request contains a description prior to this call it will be overwritten by this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The new value for this request's description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance with the description set to <code>desc</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab06b2ea8c51365961c1549c2e7108604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06b2ea8c51365961c1549c2e7108604">&#9670;&nbsp;</a></span>set_type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; pluginplay::SubmoduleRequest::set_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the property type the submodule must satisfy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the property type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance with the required property type set to <code>T</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the module has already been set and the requested property type is inconsistent with the module. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71aa44b7ead67342a77e35d205b6f121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71aa44b7ead67342a77e35d205b6f121">&#9670;&nbsp;</a></span>set_type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp; pluginplay::SubmoduleRequest::set_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a7f992c56a0ffa57cacead2bde0046921">rtti_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepluginplay_1_1type.html#a5b3cceb4e9a4b73288a4e173b92ab50d">type::input_map</a>&#160;</td>
          <td class="paramname"><em>inputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses RTTI to set the type of *this. </p>
<p>The templated <code>set_type</code> method is the preferred means of setting the property type from C++. If we want to set the property type from Python we need to set it at runtime. This overload of set_type allows the property type to be set at runtime. </p>

</div>
</div>
<a id="aad3379b093eacb1ec5e999e2250049a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3379b093eacb1ec5e999e2250049a3">&#9670;&nbsp;</a></span>submod_uuids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a772757c21c35cf30fcdef7f98b7eff96">SubmoduleRequest::submod_uuid_map</a> pluginplay::SubmoduleRequest::submod_uuids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a convenience function for calling submod_uuids on the wrapped module. </p>
<p>For memoization purposes we need to know the UUIDs of each submodule. Retrieving this information is done by calling Module::submod_uuids(). This function is a convenience function so that users don't need to unwrap the module in the <a class="el" href="classpluginplay_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule.">SubmoduleRequest</a> to call <a class="el" href="classpluginplay_1_1SubmoduleRequest.html#aad3379b093eacb1ec5e999e2250049a3" title="This is a convenience function for calling submod_uuids on the wrapped module.">submod_uuids()</a> (this function does that for you).</p>
<dl class="section return"><dt>Returns</dt><dd>A map from submodule keys to UUIDs.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem making the map. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if there is no wrapped module. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad441aa19b99ddd1e9ce5cbd57dec393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad441aa19b99ddd1e9ce5cbd57dec393">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepluginplay_1_1type.html#a8dd6f4c8509d26017a93644edc3574e0">type::rtti</a> pluginplay::SubmoduleRequest::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the RTTI of the property type this submodule must satisfy. </p>
<p>The developer must specify the property type that the submodule satisfies using set_type. This function is the accessor providing access to the type that the developer specified.</p>
<dl class="section return"><dt>Returns</dt><dd>The RTTI of the property type that the submodule must satisfy.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_optional_access</td><td>if <a class="el" href="classpluginplay_1_1SubmoduleRequest.html#a4a639cab2bfc429c171ba6c0d93af8d5" title="Has the property type the submodule needs to satisfy been set?">has_type()</a> is false. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03932df3a61dd078ba304f7621571008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03932df3a61dd078ba304f7621571008">&#9670;&nbsp;</a></span>uuid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1SubmoduleRequest.html#ad1f8e0cac07df505765a6bc4dbdd4680">SubmoduleRequest::uuid_type</a> pluginplay::SubmoduleRequest::uuid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the UUID of the wrapped module. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is no wrapped module. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07ad2fe8526464addc490e9b31b37b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ad2fe8526464addc490e9b31b37b12">&#9670;&nbsp;</a></span>value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpluginplay_1_1Module.html">Module</a> &amp; pluginplay::SubmoduleRequest::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the module used to satisfy this request in a read/write state. </p>
<p>This function allows one to retrieve the module used to satisfy the request in a read/write state. This is useful for changing inputs before running the module.</p>
<dl class="section return"><dt>Returns</dt><dd>The module satisfying this request.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the request has not been fulfilled yet. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa7e1c8be2f4595773a20fa37f0e8a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7e1c8be2f4595773a20fa37f0e8a6d">&#9670;&nbsp;</a></span>value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpluginplay_1_1Module.html">Module</a> &amp; pluginplay::SubmoduleRequest::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the module used to satisfy this request in a read-only state. </p>
<p>This function allows one to retrieve the module used to satisfy the request in a read-only state. This is useful for inspection and running the module.</p>
<dl class="section return"><dt>Returns</dt><dd>The module satisfying this request.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the request has not been fulfilled yet. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/pluginplay/<a class="el" href="submodule__request_8hpp_source.html">submodule_request.hpp</a></li>
<li>src/pluginplay/submodule_request.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
