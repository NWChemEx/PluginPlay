#pragma once
#include "Cache.hpp"
#include "SDE/attic/Module.hpp"
#include <functional>
#include <string>

namespace SDE {
namespace detail_ {
/// Forward declaration of PIMPL class
class MMImpl;

} // namespace detail_

/**
 * @brief The class responsible for handling all of the modules known to the SDE
 *
 * On the surface the ModuleManager looks a lot like an std::map, and indeed to
 * the user it functions largely as if it is.  However, under the hood there is
 * a lot more going on including: memoization, checkpointing, and (possibly)
 * dynamic loading of modules.  It is the ModuleManager's responsibility to keep
 * all that straight.
 *
 * @nosubgrouping
 */
class ModuleManager {
public:
    /// The type of the key used to retrieve a module
    using key_type = std::string;

    /// The type of a pointer to a module
    using module_pointer = typename ModuleBase::module_pointer;

    /// Type of the loaders we store internally
    using loader_type = std::function<module_pointer()>;

    /// Type of natural number returns
    using size_type = std::size_t;

    /**
     * @brief Constructs a new ModuleManager.
     *
     * The resulting ModuleManager has no modules in it.  Modules can be added
     * by using the insert function.
     *
     * @par Complexity:
     * Constant.
     *
     * @par Data Races:
     * None.
     *
     * @throw std::bad_alloc if there is insufficient memory to make a new
     *        instance of the implementation.   Strong throw guarantee.
     */
    ModuleManager();

    /**
     * @brief Takes ownership of another ModuleManager instance.
     * @param rhs The instance to take ownership of.  After this operation
     *        @p rhs is a valid, but otherwise unspecified state.
     * @throw None. No throw guarantee.
     * @par Complexity:
     * Constant.
     */
    ModuleManager(ModuleManager&& rhs) noexcept;

    /**
     * @brief Takes ownership of another ModuleManager instance.
     * @param rhs The instance to take ownership of.  After this operation
     *        @p rhs is a valid, but otherwise unspecified state.
     * @return The current instance containing @p rhs's state.
     * @throw None. No throw guarantee.
     * @par Complexity:
     * Constant.
     */
    ModuleManager& operator=(ModuleManager&& rhs) noexcept;

    /**
     * @brief Frees up all modules managed by this module manager.
     *
     * Unlike most dtors in the SDE, this one actually matters as it's
     * responsible for long-term caching of the results and ensuring any
     * dynamically opened libraries are closed properly.
     *
     * @throw None. No throw guarantee.
     *
     */
    ~ModuleManager() noexcept;

    /**
     * @brief Adds a module to the current ModuleManager with the associated
     *        key.
     *
     * Each module along with its associated parameters and submodules are
     * stored in the ModuleManager under a unique key.  The current function
     * adds a (presumably) new module to the current instance for management.
     * When requested the module will be generated by calling the @p loader.
     *
     * @param key the tag to associate with the module, must be unique and
     *            non-empty.
     * @param loader A function that returns a module, via a shared_ptr to
     *            ModuleBase.
     * @throws std::range_error if @p key is already registered.  Strong throw
     *         guarantee.
     * @throws std::invalid_argument if @p key is empty.  Strong throw
     *         guarantee.
     * @throws std::bad_alloc if there is insufficient memory to store the
     *         module's data.  Strong throw guarantee.
     *
     * @par Complexity:
     * The actual insertion is logrithmic in the number of modules present.
     *
     */
    void insert(key_type key, loader_type loader);

    /**
     * @brief Checks whether or not a module is registered under the provided
     *        key
     *
     * @param key The module key to look for.
     * @return The number of modules registered under @p key (either 0 or 1)
     * @throw None. No throw guarantee.
     *
     * @par Complexity:
     * Logrithmic in the number of modules.
     */
    size_type count(const key_type& key) const noexcept;

    /**
     * @brief Copies the parameters and submodules associated with a particular
     *        key to a new key.
     *
     * Once a module is locked there is no way to change its parameters or
     * submodules.  This function will duplicate (deep copy) a module associated
     * with a particular key.  The resulting module will not be locked and thus
     * its parameters and submodules may be changed.
     *
     * @param[in] old_key the key to be duplicated.
     * @param[in] new_key (optional) the key to duplicate @p old_key under.
     *            Must be a valid key, or the null string.  In the event of a
     *            null string, a valid, implementation defined, key will be
     *            generated for you.
     * @return The key under which your new module may be found.
     * @throws std::out_of_range if @p old_key is not an already existing key.
     * @throws std::range_error if @p new_key is already registered and was
     *         specified by the user. Strong throw guarantee.
     * @throws std::bad_alloc if there is insufficient memory to store the
     *         module's data.  Strong throw guarantee.
     * @par Complexity:
     * For all intents and purposes logrithmic in the number of modules;
     * however, this assumes that generation of a valid key is constant.  In the
     * worst case (and unlikely) scenario that this function is limited by
     * generating a unique key, the actual complexity is linear in the number of
     * tries.
     */
    key_type duplicate(const key_type& old_key,
                       const key_type& new_key = key_type{});
    /**
     * @brief Returns the module with the given key
     * @param key The tag associated with the requested module
     * @return The requested module
     * @throws std::out_of_range if @p key is not associated with a module.
     *         Strong throw guarantee.
     * @par Complexity:
     * Lookup time is logrithmic in the number of modules.
     *
     */
    module_pointer at(const key_type& key);

private:
    /// The actual implementation
    std::unique_ptr<detail_::MMImpl> pimpl_;
};

} // namespace SDE
